---
layout: post
title:  "数据可视化-data-visualization"
date:   2013-10-30 15:06:00
categories: 数据挖掘
tags: 数据分析 graphviz echarts pyecharts matplotlib seaborn
excerpt: 数据可视化工具及经验汇总
author: 鹤啸九天
mathjax: true
---

* content
{:toc}

# 总结

- 可视化方法
- 【2020-8-7】[Python数据可视化工具测评：5大工具谁是第一？](https://www.toutiao.com/i6857488478171562510/?tt_from=mobile_qq&utm_campaign=client_share&timestamp=1596811627&app=news_article&utm_source=mobile_qq&utm_medium=toutiao_android&use_new_style=1&req_id=202008072247070101470841452B60EFB6&group_id=6857488478171562510)
    - Matplotlib、Pyecharts、Seaborn、Plotly、Bokeh这五大工具
    - ![](http://p3-tt.byteimg.com/large/pgc-image/1a00b53e61244311b268f235036f4d80?from=pc)
    - 评测维度
    - ![](http://p1-tt.byteimg.com/large/pgc-image/3b7002a2598e49719906d8c7bc6fd9ee?from=pc)
- Seaborn和Plotly、bokeh有一个共同的地方就是虽然强大，但是网上有关这三个库的教程、讨论都远少于Pyecharts与Matplotlib

|**工具**|**得分**|**分布**|**示例**|
|---|---|---|---|
|Pyecharts|85|![](http://p3-tt.byteimg.com/large/pgc-image/7093619494244189aeb5eee909b73060?from=pc)|![](http://p6-tt.byteimg.com/large/pgc-image/3c90d333349f4a7ebbe633094712bcca?from=pc)|
|Matplotlib|77|![](http://p3-tt.byteimg.com/large/pgc-image/646166041e6343d39c033b2ebab97fdf?from=pc)|![](http://p1-tt.byteimg.com/large/pgc-image/83e98dc271c345b29f8ff7ac9291719f?from=pc)|
|Plotly|76|![](http://p1-tt.byteimg.com/large/pgc-image/b61e531a2f824044b8c2e99427b08973?from=pc)|![](http://p6-tt.byteimg.com/large/pgc-image/83a94c90fbd14a2692c67747f61513e7?from=pc)|
|Bokeh|71|![](http://p6-tt.byteimg.com/large/pgc-image/8ccde1b5c1be4fa7ac39f0c9a6b76416?from=pc)|![](http://p6-tt.byteimg.com/large/pgc-image/ca1f4b4b76f045d987f88a2be6a4fd67?from=pc)|
|Seaborn|72|![](http://p6-tt.byteimg.com/large/pgc-image/355779f843154053b67fb29c1beb7dd3?from=pc)|![](http://p3-tt.byteimg.com/large/pgc-image/5380934b5a2046e082a5d13581d18075?from=pc)|

# matplotlib

## Matplotlib

- Python 有非常丰富的第三方绘图库，matplotlib 使用起来也许并不是很便捷，因为图上每个元素都需要自己来定制。但仔细体会 matplotlib 背后的设计思想是很有趣的事情。seaborn 之类的绘图库是基于 matplotlib 封装的，因而后期需要自己灵活定制图形时就大大受用了。本文的两幅思维导图是基于两种不同的思路绘制的，偶有内容交叉，日常使用可以选择自己熟悉的方式（网上的教程大多是基于过程的函数式编程，即 pyplot 方法）。**建议配合最后附上出的参考资料学习**。

![](https://raw.githubusercontent.com/woaielf/woaielf.github.io/master/_posts/Pic/1704/170427-1.png)

![](https://raw.githubusercontent.com/woaielf/woaielf.github.io/master/_posts/Pic/1704/170427-2.png)

Reference
> 《Python for data analysis》<br>
[Matplotlib: Python plotting — Matplotlib 2.0.2 documentation](http://matplotlib.org/index.html) <br>
[绘图: matplotlib核心剖析](http://www.cnblogs.com/vamei/archive/2013/01/30/2879700.html#commentform) <br>
[【数据可视化】 之 Matplotlib](https://zhuanlan.zhihu.com/p/21443208?utm_medium=social&utm_source=qq?utm_medium=social&utm_source=qq) <br>
[Python--matplotlib绘图可视化知识点整理](http://python.jobbole.com/85106/) <br>
[一份非常好的Matplotlib 教程](http://blog.csdn.net/u011497262/article/details/52325705)

- 绘制热力图

```python
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

# 这里是创建一个数据
vegetables = ["cucumber", "tomato", "lettuce", "asparagus",
              "potato", "wheat", "barley"]
farmers = ["Farmer Joe", "Upland Bros.", "Smith Gardening",
           "Agrifun", "Organiculture", "BioGoods Ltd.", "Cornylee Corp."]

harvest = np.array([[0.8, 2.4, 2.5, 3.9, 0.0, 4.0, 0.0],
                    [2.4, 0.0, 4.0, 1.0, 2.7, 0.0, 0.0],
                    [1.1, 2.4, 0.8, 4.3, 1.9, 4.4, 0.0],
                    [0.6, 0.0, 0.3, 0.0, 3.1, 0.0, 0.0],
                    [0.7, 1.7, 0.6, 2.6, 2.2, 6.2, 0.0],
                    [1.3, 1.2, 0.0, 0.0, 0.0, 3.2, 5.1],
                    [0.1, 2.0, 0.0, 1.4, 0.0, 1.9, 6.3]])

# 这里是创建一个画布
fig, ax = plt.subplots()
im = ax.imshow(harvest)

# 这里是修改标签
# We want to show all ticks...
ax.set_xticks(np.arange(len(farmers)))
ax.set_yticks(np.arange(len(vegetables)))
# ... and label them with the respective list entries
ax.set_xticklabels(farmers)
ax.set_yticklabels(vegetables)

# 因为x轴的标签太长了，需要旋转一下，更加好看
# Rotate the tick labels and set their alignment.
plt.setp(ax.get_xticklabels(), rotation=45, ha="right",
         rotation_mode="anchor")

# 添加每个热力块的具体数值
# Loop over data dimensions and create text annotations.
for i in range(len(vegetables)):
    for j in range(len(farmers)):
        text = ax.text(j, i, harvest[i, j],
                       ha="center", va="center", color="w")
ax.set_title("Harvest of local farmers (in tons/year)")
fig.tight_layout()
plt.colorbar(im)
plt.show()
```

![](https://pic1.zhimg.com/80/v2-688f8d2f666ccbbd221c4be9826863e6_720w.jpg?source=1940ef5c)


```python
from matplotlib import pyplot as plt
from matplotlib import cm as cm

def correlation_matrix(df):
    fig = plt.figure(figsize=(50,30))
    ax1 = fig.add_subplot(111)
    ax1.set_title('intent translate map',fontsize=40,color='b')
    cmap = cm.get_cmap('jet', 30) 
    cax = ax1.imshow(df.corr(), interpolation="nearest", cmap=cmap)
    ax1.grid(True)
    #plt.title('Abalone Feature Correlation') 
    labels_x = df.index
    labels_y = df.columns
    #labels=['Sex','Length','Diam','Height','Whole','Shucked','Viscera','Shell','Rings',]
    ax1.set_xticklabels(labels_x,fontsize=20)
    ax1.set_yticklabels(labels_y,fontsize=20)
    # Add colorbar, make sure to specify tick locations to match desired ticklabels
    fig.colorbar(cax, ticks=[.75,.8,.85,.90,.95,1])
    plt.show()

correlation_matrix(df)
```

# turtle

- 【2021-4-6】[Python的turtle库使用-画出好看的图形](https://www.toutiao.com/i6947915708235907591/),1969年诞生,Python语言的标准库之一,入门级的图形绘制函数库, [官方文档](https://docs.python.org/3/library/turtle.html), [入门指南](https://blog.csdn.net/sandalphon4869/article/details/99443949)
- [布局](https://img-blog.csdnimg.cn/20190813115627644.png)
  - ![](https://img-blog.csdnimg.cn/20190813115627644.png)
- 示例, [彩色螺旋线](https://p3-tt.byteimg.com/origin/pgc-image/e649fedd95824c0ca17582dd36f07b32)

```python
import turtle

turtle.shape('turtle')
turtle.speed(9)            # 画笔速度
turtle.pensize(2)			# 画笔的宽度
turtle.bgcolor("black")		# 画布背景色
colors = ["red","yellow","green","blue"]	# 定义画笔线色

for i in range(255):		# 循环一次 画一条线
    turtle.forward(2 * i) 	        # 向当前方向前进n像素
    turtle.color(colors[i % 4])	# 根据求余 调整画笔线色
    turtle.left(91)                # 向左旋转91度

turtle.done()
```

![](https://p3-tt.byteimg.com/origin/pgc-image/e649fedd95824c0ca17582dd36f07b32)

# seaborn

- 建立在matplotlib上
- Seaborn的heatmap[参数介绍](https://blog.csdn.net/m0_38103546/article/details/79935671)
  - data：矩阵数据集，可以使numpy的数组（array），如果是pandas的dataframe，则df的index/column信息会分别对应到heatmap的columns和rows
  - linewidths,热力图矩阵之间的间隔大小
  - vmax,vmin, 图例中最大值和最小值的显示值，没有该参数时默认不显示
  - cmap：matplotlib的colormap名称或颜色对象；如果没有提供，默认为cubehelix map (数据集为连续数据集时) 或 RdBu_r (数据集为离散数据集时)

```python
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import random

np.random.seed(1)
data = np.random.rand(16, 16)

sns.set()
ax = sns.heatmap(data, center=0)
#plt.savefig('res.png', dpi=300)
plt.show()
```
![](https://pic2.zhimg.com/80/v2-c4a0b7721ad6d32762a782e573b41d43_720w.jpg?source=1940ef5c)

```python
f, (ax1,ax2) = plt.subplots(figsize = (10, 8),nrows=2)
# cubehelix map颜色
cmap = sns.cubehelix_palette(start = 1.5, rot = 3, gamma=0.8, as_cmap = True)
sns.heatmap(pt, linewidths = 0.05, ax = ax1, vmax=15000, vmin=0, cmap=cmap)
ax1.set_title('cubehelix map')
ax1.set_xlabel('')
ax1.set_xticklabels([]) #设置x轴图例为空值
ax1.set_ylabel('kind')
# matplotlib colormap
sns.heatmap(pt, linewidths = 0.05, ax = ax2, vmax=15000, vmin=0, cmap='rainbow') 
# rainbow为 matplotlib 的colormap名称
ax2.set_title('matplotlib colormap')
ax2.set_xlabel('region')
ax2.set_ylabel('kind')
f.savefig('sns_heatmap_cmap.jpg', bbox_inches='tight')

# 加数值标注
np.random.seed(0)
x = np.random.randn(10, 10)
f, (ax1, ax2) = plt.subplots(figsize=(8,8),nrows=2)
sns.heatmap(x, annot=True, ax=ax1)
sns.heatmap(x, annot=True, fmt='.1f', ax=ax2)
f.savefig('sns_heatmap_fmt.jpg')
```

![](https://pic1.zhimg.com/80/v2-3cbbbc15f7116beded4643bf77a68214_hd.jpg)
![](https://pic3.zhimg.com/80/v2-50d816db7cc91dbf4e48a9860d0c1800_hd.jpg)

# pyecharts

## 简介

Echarts是一个由百度开源的数据可视化工具，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。pyecharts是一个全新的可视化绘图工具，因此它的绘图逻辑完全不同于前面说到的matplotlib、seaborn、plotly。

## 版本

- 【2020-12-08】pyecharts分为v0.5和v1两个大版本，v0.5和v1两个版本不兼容，风格迥异，v1是一个全新的版本。旧版基本放弃。
- 查看版本：print(pyecharts.version)
- 旧版是**过程式**调用，新版是**链式**调用

## 安装

命令：

```python
pip install pyecharts
# 如果需要绘制地图，下列地图数据包需要安装
pip install echarts-countries-pypkg
pip install echarts-china-provinces-pypkg
pip install echarts-china-cities-pypkg
pip install echarts-china-counties-pypkg
pip install echarts-china-misc-pypkg
```

- [pyecharts官网](https://pyecharts.org/#/zh-cn/quickstart)，示例程序

注意：
>- 在使用 Pandas&Numpy 时，请确保将数值类型转换为 python 原生的 int/float。比如整数类型请确保为 int，而不是 numpy.int32

## 基础知识

[【干货分享】pyecharts的绘图原理详解](https://zhuanlan.zhihu.com/p/301058247)

pyecharts的绘图逻辑分为以下几步。
- ① 选择**图表类型**；散点、折线、饼图以及地图等
  - from pyecharts.charts import Scatter 
  - ![常见图表类型](https://pic1.zhimg.com/80/v2-d75494d592313e6adcc0d89658fbb2c0_720w.jpg)
- ② 声明图形类并添加数据；每一个图形库都是被pyecharts作者封装成为了一个**类**，即面向对象，用类时，需要**实例**化这个类。声明类之后，相当于初始化了一个**画布**，之后的绘图就是在这个画布上进行。接下来要做的就是添加数据，pyecharts中添加数据共有2种方式，一种是普通的**过程式**添加数据，一种是**链式**调用(观察下面代码)来添加数据
  - 散点图、折线图等二维数据图形，它既有X轴，又有Y轴，两个轴都要添加
    - .add_xaxis(xaxis_data=x)为X轴添加数据；
    - .add_yaxis(series_name='', y_axis=y)为Y轴添加数据；series_name参数必须有，添加的数据标题
  - 饼图、地图没有X轴、Y轴区分的图形，直接使用add()方法添加即可
    - .add(series_name='', data_pair=[(i,j)for i,j in zip(lab,num)])；
- ③ 选择**全局变量**；调节各种各样的参数，把图形变得更好看. 常用的有: [图片总结](https://pic1.zhimg.com/80/v2-e0dc24bb8b127698ee04f322d99bb968_720w.jpg)
  - `标题`配置项: TitleOpts
  - `图例`配置项: LegendOpts
  - `工具`配置项: ToolboxOpts
  - `视觉映射`配置项: VisualMapOpts
  - `提示框`配置项: TooltipOpts
  - `区域缩放`配置项: DataZoomOpts
  - ![](https://pic1.zhimg.com/80/v2-e0dc24bb8b127698ee04f322d99bb968_720w.jpg)
  - 还有**初始化**画布大小：InitOpts，示例：
    - import pyecharts.options as opts
    - pie = Pie(init_opts=opts.InitOpts(width="700px",height="300px")) 
- ④ **显示**及保存图表；
  - render('a.html') # html格式展示，链接分享
  - render_notebook() # 渲染到jupyter notebook

```python
# 1.选择图表类型：我们使用的是散点图，就直接从charts模块中导入Scatter这个图形。  
from pyecharts.charts import Scatter  
import numpy as np  

x = np.linspace(0,2 * np.pi,100)  
y = np.sin(x)  

(  
    # 注意：使用什么图形，就要实例化该图形的类；  
    # 2.我们绘制的是Scatter散点图，就需要实例化散点图类，直接Scatter() 即可；  
    Scatter()   
    # 实例化类后，接着就是添加数据，下面这种方式就是使用“链式调用”的方式绘图；  
    # 注意：散点图有X、Y轴，因此需要分别给X轴、Y轴添加数据；  
    # 3.我们先给X轴添加数据；  
    .add_xaxis(xaxis_data=x)  
    # 4.我们再给Y轴添加数据；  
    .add_yaxis(series_name="这个图是干嘛的",y_axis=y)  
).render_notebook()  
```

### 画布型号

代码

```python
from pyecharts.charts import Bar
from pyecharts import options as opts

bar = (
    Bar(init_opts=opts.InitOpts(width="1700px",
                                height="750px",
                                page_title="画布大小设置"))
    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
    .add_yaxis("商家B", [15, 6, 45, 20, 35, 66])
    .set_global_opts(title_opts=opts.TitleOpts(title="商家销售汇总",subtitle="分类汇总"))
    #.set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题"))
)
bar.render("123.html")
```

### 画布主题

代码

```python
from pyecharts.charts import Bar
from pyecharts import options as opts
# 内置主题类型可查看 pyecharts.globals.ThemeType
from pyecharts.globals import ThemeType


bar = (
    Bar(init_opts=opts.InitOpts(width="1700px",
                                height="750px",
                                page_title="画布设置",
                                theme=ThemeType.DARK))
    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
    .add_yaxis("商家B", [15, 6, 45, 20, 35, 66])
    .set_global_opts(title_opts=opts.TitleOpts(title="商家销售汇总",subtitle="分类汇总"))
    #.set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题"))
)
bar.render("123.html")
```

### 坐标轴设置

[pyecharts1.7 坐标轴设置：X轴、Y轴通用](https://blog.csdn.net/H_biubiu/article/details/106100656)

- type_ ：坐标轴类型， 可选：
    - 'value' 数值轴，适用于连续数据。
    - 'category' 类目轴，适用于离散的类目数据
    - 'time' 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。
    - 'log' 对数轴。适用于对数数据。


```python
from random import randint

from pyecharts import options as opts
from pyecharts.charts import Bar
from pyecharts.commons.utils import JsCode

x_data = ['分类1','分类2','分类3','分类4','分类5',]
y1_data = [0.72,0.61,0.98,0.92,0.67,]
y2_data = [d * randint(1, 10) for d in y1_data]

instance_bar = (
    Bar()
        .add_xaxis(xaxis_data=x_data)
        .add_yaxis(series_name='系列1', yaxis_data=y1_data)
        .add_yaxis(series_name='系列2', yaxis_data=y2_data)
        .set_global_opts( # 全局设置
        xaxis_opts=opts.AxisOpts( # （1）x轴设置
            type_='category',  # value数值轴，category类目轴，time时间轴，log对数轴
            name='x名称',  # Optional[str]
            is_show=True,  # bool， 是否显示坐标轴
            is_scale=False,  # bool，坐标刻度是否包含零刻度，只在数值轴中（type： ‘value’）有效。设置成 true 后坐标刻度不会强制包含零刻度。在双数值轴的散点图中比较有用。在设置 min 和 max 之后该配置项无效
            is_inverse=True,  # bool，是否是反向坐标轴
            name_location='start',  # str，坐标轴名称显示位置，'start'，'middle'/'center'，'end'
            name_gap=15,  # Numeric，坐标轴名称与轴线之间的距离
            name_rotate=20,  # Optional[Numeric]，坐标轴名字旋转，角度值
            name_textstyle_opts=opts.TextStyleOpts( # （2）坐标轴名称的文字样式
                color='blue',  # 颜色
                font_style=None,  # 字体，可选：‘normal’，‘italic’，‘oblique’
                font_weight=None,  # 粗细，可选：‘normal’，‘bold’，‘bolder’，‘lighter’
                font_family=None,  # 字体, ‘serif’ , ‘monospace’, ‘Arial’, ‘Courier New’, ‘Microsoft YaHei’, …
                font_size=None,  # 字体大小
                align=None,  # 水平对齐方式，默认自动
                vertical_align=None,  # 垂直对齐方式，默认自动
                line_height=None,  # 行高
                background_color='yellow',  # 文字块背景色。可以是直接的颜色值，例如：’#123234’, ‘red’, ‘rgba(0,23,11,0.3)’
                border_color=None,  # 文字块边框颜色
                border_width=None,  # 文字块边框高度
                border_radius=None,  # 文字块的圆角
                padding=None,  # Union[Numeric, Sequence, None]，文字块的内边距。例：padding: [3, 4, 5, 6]：表示 [上, 右, 下, 左] 的边距，padding: 4：表示 padding: [4, 4, 4, 4]，padding: [3, 4]：表示 padding: [3, 4, 3, 4]
                shadow_color=None,  # 文字块的背景阴影颜色
                shadow_blur=None,  # 文字块的背景阴影长度
                width=None,  # 文字块的宽度
                height=None,  # 文字块的高度
                rich=None,  # Optional[dict]，自定义富文本样式
            ),
            interval=30,  # Optional[Numeric]，坐标轴间隔，强制设置坐标轴分割间隔。无法在类目轴中使用。在时间轴（type： ‘time’）中需要传时间戳，在对数轴（type： ‘log’）中需要传指数值
            grid_index=0,  # Numeric，坐标轴所在的 grid 的索引，默认位于第一个 grid
            position='',  # Optional[str]，坐标轴位置可选：'top'，'bottom'，默认 grid 中的第一个 x 轴在 grid 的下方（'bottom'），第二个 x 轴视第一个 x 轴的位置放在另一侧
            offset=0,  # Numeric，坐标轴偏移，X 轴相对于默认位置的偏移，在相同的 position 上有多个 X 轴的时候有用
            split_number=5,  # Numeric，坐标轴的分割段数，需要注意的是这个分割段数只是个预估值，最后实际显示的段数会在这个基础上根据分割后坐标轴刻度显示的易读程度作调整。在类目轴中无效。
            boundary_gap='',  # Union[str, bool, None]，坐标轴两边留白策略。类目轴和非类目轴的设置和表现不一样。类目轴中 boundaryGap 可以配置为 true 和 false。默认为 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。非类目轴，包括时间，数值，对数轴，boundaryGap是一个两个值的数组，分别表示数据最小值和最大值的延伸范围，可以直接设置数值或者相对的百分比，在设置 min 和 max 后无效。boundaryGap： [‘20%’, ‘20%’]
            min_='',  # Union[Numeric, str, None]，坐标轴最小值
            max_='',  # Union[Numeric, str, None]，坐标轴最大值
            min_interval=0,  # Numeric，坐标轴最小间隔，自动计算的坐标轴最小间隔大小。例如可以设置成1保证坐标轴分割刻度显示成整数。只在数值轴或时间轴中（type： ‘value’ 或 ‘time’）有效。
            max_interval=0,  # Optional[Numeric] ，坐标轴最大间隔，自动计算的坐标轴最大间隔大小。例如，在时间轴（（type： ‘time’））可以设置成 3600 * 24 * 1000 保证坐标轴分割刻度最大为一天。只在数值轴或时间轴中（type： ‘value’ 或 ‘time’）有效。
            axisline_opts=opts.AxisLineOpts( # （3）坐标轴轴线相关设置
                is_show=True, # 是否显示坐标轴轴线。
                is_on_zero=True, # X 轴或Y 轴的轴线是否在另一个轴的 0 刻度上，只有在另一个轴为数值轴且包含 0 刻度时有效。
                on_zero_axis_index=0,
                symbol=None,
                linestyle_opts=opts.LineStyleOpts( # 坐标轴线风格配置项
                    is_show=True,
                    width=1,
                    opacity=1,
                    curve=0,
                    type_="solid",
                    color=None,
                )
            ),
            axistick_opts=opts.AxisTickOpts( # （4）坐标轴刻度相关设置
                is_show=True,
                is_align_with_label=True,
                is_inside=True,
                length=20,
                linestyle_opts=opts.LineStyleOpts(
                    is_show=True,
                    width=1,
                    opacity=1,
                    curve=0,
                    type_="solid",
                    color=None,
                )
            ),
            axislabel_opts=opts.LabelOpts(
                is_show=True,  # bool
                position="top",  # Union[str, Sequence]
                color='pink',  # Optional[str]
                font_size=None,  # Optional[Numeric]
                font_style=None,  # Optional[str]
                font_weight=None,  # Optional[str]
                font_family=None,  # Optional[str]
                rotate=10,  # Optional[Numeric]
                margin=8,  # Optional[Numeric]\,
                interval=None,  # Union[Numeric, str, None]
                horizontal_align=None,  # Optional[str]
                vertical_align=None,  # Optional[str]
                formatter=JsCode("""
                function(value,index) {
                  if (index === 2) {
                    return 'formatter';
                  } else {
                    return value;
                  }
                }
                """),  # Optional[JSFunc] 回调函数
                # 字符串模板 formatter='-{value}-',
                background_color=None,  # Optional[str]
                border_color=None,  # Optional[str]
                border_width=None,  # Optional[Numeric]
                border_radius=None,  # Optional[Numeric]
                rich=None,  # Optional[dict]
            ),
            axispointer_opts=opts.AxisPointerOpts( # 坐标轴指示器设置
                is_show=True,
                link=None,
                type_="line",
                label=None,
                linestyle_opts=opts.LineStyleOpts(
                    is_show=True,
                    width=10,
                    opacity=0.5,
                    curve=0,
                    type_="solid",
                    color='green',
                ),
            ),
            splitarea_opts=opts.SplitAreaOpts( # 坐标轴在 grid 区域中的分隔区域设置
                is_show=True,
                areastyle_opts=opts.AreaStyleOpts(
                    opacity=0.05,
                    color={
                        'type': 'linear',
                        'x': 0,
                        'y': 0,
                        'x2': 0,
                        'y2': 1,
                        'colorStops': [{
                            'offset': 0, 'color': 'red'  # 0% 处的颜色
                        }, {
                            'offset': 1, 'color': 'blue'  # 100% 处的颜色
                        }],
                        'global': False  # 缺省为 false
                    }
                )

            ),
            splitline_opts=opts.SplitLineOpts( # 坐标轴在 grid 区域中的分隔线设置
                is_show=True,
                linestyle_opts=opts.LineStyleOpts(
                    is_show=True,
                    width=1,
                    opacity=1,
                    curve=0,
                    type_="solid",
                    color='#0099ff',
                )
            )

        )
    )
)
```

### 示例

```python
from pyecharts.charts import Bar

#===========过程式调用==========
bar = Bar()
bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
bar.add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
# render 会生成本地 HTML 文件，默认会在当前目录生成 render.html 文件
# 也可以传入路径参数，如 bar.render("mycharts.html")
bar.render()

#============链式调用==========
from pyecharts.charts import Bar

bar = (
    Bar()
    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
)
bar.render()

```
- 使用 options 配置项，在 pyecharts 中，一切皆 Options。

```python
from pyecharts.charts import Bar
from pyecharts import options as opts

# V1 版本开始支持链式调用
# 你所看到的格式其实是 `black` 格式化以后的效果
# 可以执行 `pip install black` 下载使用
bar = (
    Bar()
    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
    .set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题"))
    # 或者直接使用字典参数
    # .set_global_opts(title_opts={"text": "主标题", "subtext": "副标题"})
)
bar.render()

# 不习惯链式调用的开发者依旧可以单独调用方法
bar = Bar()
bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
bar.add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
bar.set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题"))
bar.render()

# 设置主题
from pyecharts.globals import ThemeType

bar = (
    Bar(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))
    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])
    .add_yaxis("商家B", [15, 6, 45, 20, 35, 66])
    .set_global_opts(title_opts=opts.TitleOpts(title="主标题", subtitle="副标题"))
)
```

效果示例
- ![](https://user-images.githubusercontent.com/19553554/55602584-f2b36780-5798-11e9-8ce4-b579344b3a8f.png)

## 图表详解

- [示例](https://gallery.pyecharts.org/#/README)

### 饼图

代码：

```python
from pyecharts.charts import Pie

data = [['交易定金', 2],
 ['交易服务费', 3],
 ['交易流程-全款', 5],
 ['交易流程-公积金', 6],
 ['交易流程-商贷', 33],
 ['交易流程-组合贷', 2],
 ['征信与贷款', 2],
 ['户口保证金', 1],
 ['物业保证金', 3],
 ['税费政策', 14],
 ['解抵押流程', 7],
 ['贝壳服务内容', 15],
 ['资金监管', 18],
 ['限购限售政策', 1]]

pie = (Pie(init_opts=opts.InitOpts(width="1440px", height="720px"))
    .add("交互成功的签约意图分布", data,
            radius=["30%", "75%"], # radius=[40,75]，radius:半径
            center=["25%", "50%"],
            rosetype="radius",
            label_opts=opts.LabelOpts(is_show=True))
     .set_global_opts(
        title_opts=opts.TitleOpts(title="签约意图占比分布"),   # TitleOpts:标题设置项
         toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        legend_opts=opts.LegendOpts(pos_top="5%",pos_right="15%", orient='vertical')) #LegendOpts：图例配置项
) 
pie.render_notebook()
```


### 柱形图

```python
from pyecharts.charts import Bar
from pyecharts import options as opts

# V1 版本开始支持链式调用
bar = (
    Bar()
    .add_xaxis(["衬衫", "毛衣", "领带", "裤子", "风衣", "高跟鞋", "袜子"])
    .add_yaxis("商家A", [114, 55, 27, 101, 125, 27, 105])
    .add_yaxis("商家B", [57, 134, 137, 129, 145, 60, 49])
    .set_global_opts(title_opts=opts.TitleOpts(title="某商场销售情况"))
)
bar.render()

# 不习惯链式调用的开发者依旧可以单独调用方法
bar = Bar()
bar.add_xaxis(["衬衫", "毛衣", "领带", "裤子", "风衣", "高跟鞋", "袜子"])
bar.add_yaxis("商家A", [114, 55, 27, 101, 125, 27, 105])
bar.add_yaxis("商家B", [57, 134, 137, 129, 145, 60, 49])
bar.set_global_opts(title_opts=opts.TitleOpts(title="某商场销售情况"))
#bar.render()
bar.render_notebook()
```

### 分页混合

- 【2021-8-21】多种图类型分布在一个页面的多个tab页

```python
import pyecharts.options as opts
from pyecharts.charts import Bar, Pie, Page, Tab
from pyecharts.components import Table

# 示例数据
train_list = [['NLU00000',
  '还有双鸭山到淮阴的汽车票吗13号的',
  'Travel-Query',
  'destination:淮阴+departure:双鸭山+datetime_date:13号+query_type:汽车票'],
 ['NLU00001', '从这里怎么回家', 'Travel-Query', 'destination:家+query_type:导航'],
 ['NLU00002', '随便播放一首专辑阁楼里的佛里的歌', 'Music-Play', 'album:阁楼+play_mode:随机播放'],
 ['NLU00003', '给看一下墓王之王嘛', 'FilmTele-Play', 'name:墓王之王'],
 ['NLU00004',
  '我想看挑战两把s686打突变团竞的游戏视频',
  'Video-Play',
  'name:挑战两把s686打突变团竞的游戏视频'],
 ['NLU00005', '我想看和平精英上战神必备技巧的游戏视频', 'Video-Play', 'name:和平精英上战神必备技巧的游戏视频'],
 ['NLU00006',
  '2019年古装爱情电视剧小女花不弃的花絮播放一下',
  'Video-Play',
  'name:小女花不弃的花絮+datetime_date:2019年'],
 ['NLU00007', '找一个2004年的推理剧给我看一会呢', 'FilmTele-Play', 'tag:推理+age:2004年'],
 ['NLU00008',
  '自驾游去深圳都经过那些地方啊',
  'Travel-Query',
  'destination:深圳+query_type:导航'],
 ['NLU00009',
  '给我转播今天的女子双打乒乓球比赛现场',
  'Video-Play',
  'datetime_date:今天+name:女子双打乒乓球比赛现场']]

stat_info = {'intent': {'Travel-Query': 1000,
  'Music-Play': 1000,
  'FilmTele-Play': 1000,
  'Video-Play': 1000,
  'Radio-Listen': 1000,
  'HomeAppliance-Control': 1000,
  'Weather-Query': 1000,
  'Alarm-Update': 1000,
  'Calendar-Query': 1000,
  'TVProgram-Play': 50,
  'Audio-Play': 50},
 'slot': {'destination': 917,
  'departure': 384,
  'datetime_date': 3244,
  'query_type': 945,
  'album': 158,
  'play_mode': 396,
  'name': 2236,
  'tag': 384,
  'age': 367,
'artist': 1150,
  'channel': 622,
  'song': 424,
  'instrument': 109,
  'appliance': 963,
  'command': 994,
  'details': 652,
  'index': 503,
  'city': 840,
  'datetime_time': 1143,
  'notes': 696,
  'play_setting': 233,
  'language': 152,
  'type': 419,
  'region': 458,
  'frequency': 331}}

all_num = {}
table_data = {}
for name in ('intent', 'slot'):
    all_num[name] = sum(stat_info[name].values())
    table_data[name] = [[k,v,'{:.2f}'.format(v*100/all_num[name])] for k,v in stat_info[name].items()]
# ============== 表格 =============
table_sample = Table()
headers = ['id', 'text', 'intent', 'slot_info']
rows = train_list
table_sample.add(headers, rows).set_global_opts(
    title_opts=opts.ComponentTitleOpts(title="训练集数据示例")
)

table_intent = Table()
headers = ["意图名", "频次", "占比(%)"]
rows = table_data['intent']
table_intent.add(headers, rows).set_global_opts(
    title_opts=opts.ComponentTitleOpts(title="意图分布")
)
table_slot = Table()
headers = ["槽位名", "频次", "占比(%)"]
rows = table_data['slot']
table_slot.add(headers, rows).set_global_opts(
    title_opts=opts.ComponentTitleOpts(title="槽位分布")
)
# ============== 柱形图 =============
bar_intent = (Bar()
        .add_xaxis(list(stat_info['intent'].keys()))
        .add_yaxis("意图", list(stat_info['intent'].values()))
        .set_global_opts(
            title_opts=opts.TitleOpts(title="意图频次"),
            #datazoom_opts=[opts.DataZoomOpts()], # 拖拽功能
            toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        )
)
bar_slot = (Bar()
        .add_xaxis(list(stat_info['slot'].keys()))
        .add_yaxis("槽位", list(stat_info['slot'].values()))
        .set_global_opts(
            title_opts=opts.TitleOpts(title="槽位频次"),
            #datazoom_opts=[opts.DataZoomOpts()],
            toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        )
)
# ============== 饼图 =============
pie_intent = (Pie()
    .add("意图分布", list(stat_info['intent'].items()),
            radius=["30%", "75%"], # radius=[40,75]，radiius:半径
            center=["25%", "50%"],
            rosetype="radius",
            label_opts=opts.LabelOpts(is_show=True))
     .set_global_opts(
        title_opts=opts.TitleOpts(title="意图占比分布"),   # TitleOpts:标题设置项
         toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        legend_opts=opts.LegendOpts(pos_top="5%",pos_right="15%", orient='vertical')) #LegendOpts：图例配置项
) 
pie_slot = (Pie()
    .add("槽位分布", list(stat_info['slot'].items()),
            radius=["30%", "75%"], # radius=[40,75]，radiius:半径
            center=["25%", "50%"],
            rosetype="radius",
            label_opts=opts.LabelOpts(is_show=True))
     .set_global_opts(
        title_opts=opts.TitleOpts(title="槽位占比分布"),   # TitleOpts:标题设置项
        toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        legend_opts=opts.LegendOpts(pos_top="5%",pos_right="15%", orient='vertical')) #LegendOpts：图例配置项
)
#pie.render("环形图.html")
#pie.render_notebook()
# ============== 汇总 =============
# 绘制在一张图里
# page = Page(layout=Page.SimplePageLayout)
# page.add(table_sample, table_intent, table_slot, bar_intent, bar_slot, pie_intent, pie_slot)
# page.render("ccf.html")
# page.render_notebook()

tab = Tab()
tab.add(table_sample, "训练数据样例")
tab.add(table_intent, "意图分布-表")
tab.add(table_slot, "槽位分布-表")
tab.add(bar_intent, "意图分布-柱形图")
tab.add(bar_slot, "槽位分布-柱形图")
tab.add(pie_intent, "意图分布-饼图")
tab.add(pie_slot, "槽位分布-饼图")
tab.render("ccf.html")
tab.render_notebook()
```

### 动画

【2021-6-14】按照时间线轮播，[kaggle代码地址](https://www.kaggle.com/wqw547243068/finace)

```python
# -*- coding: UTF-8 -*-
import copy
import random

NUM = 10
wealth_list = [100]*NUM
person_id = [ '编号{}'.format(i) for i in range(NUM)]
print("迭代前的财富分配：{}".format(wealth_list))
wealth_process = {}
MAX = 1000000
stop = [1, 1000, 10000, 100000, MAX]
for iter in range(MAX):
	for i,v in enumerate(wealth_list):
		send_person = random.randint(0,NUM-1)
		#print('第{}轮: {} -> {}'.format(iter, i, send_person))
		#if wealth_list[i] > 0:
		#	wealth_list[i] -= 1
		wealth_list[i] -= 1
		wealth_list[send_person] += 1
	if iter+1 in stop:
		wealth_process[iter+1] = {'data': [], 'range':[]}
		wealth_process[iter+1]['range'] = [min(wealth_list), max(wealth_list), max(wealth_list)/min(wealth_list),sum(wealth_list)/NUM]
		wealth_process[iter+1]['data'] = copy.deepcopy(wealth_list)
        
		print("迭代{}轮后的财富分配：[{},{}], 极差：{}, 均值:{}, 详情：{}".format(iter+1, 
                       *wealth_process[iter+1]['range'], wealth_process[iter+1]['data']))
print("迭代{}轮后的财富分配：{}".format(iter+1, wealth_list))


from pyecharts import options as opts
from pyecharts.charts import Bar, Timeline
from pyecharts.commons.utils import JsCode
#from pyecharts.faker import Faker

#x = Faker.choose()
x = person_id
tl = Timeline()
for i in wealth_process:
    bar = (
        Bar()
        .add_xaxis(x)
        .add_yaxis("财富值", wealth_process[i]['data'])
        #.add_yaxis("商家B", Faker.values())
        .set_global_opts(
            #title_opts=opts.TitleOpts("幂律分布：财富随机分配实验,第{}轮".format(i)),
            title_opts=opts.TitleOpts(title="幂律分布：财富随机分配实验",
                    subtitle="{}人，每人底钱100元，每轮随机给别人1元，迭代{}轮后，[{},{}], 均值{:.2f}, 极差{}".format(NUM, MAX,
                                                                             *wealth_process[i]['range'])),
            graphic_opts=[
                opts.GraphicGroup(
                    graphic_item=opts.GraphicItem(
                        rotation=JsCode("Math.PI / 4"),
                        bounding="raw",
                        right=100,
                        bottom=110,
                        z=100,
                    ),
                    children=[
                        opts.GraphicRect(
                            graphic_item=opts.GraphicItem(
                                left="center", top="center", z=100
                            ),
                            graphic_shape_opts=opts.GraphicShapeOpts(
                                width=400, height=50
                            ),
                            graphic_basicstyle_opts=opts.GraphicBasicStyleOpts(
                                fill="rgba(0,0,0,0.3)"
                            ),
                        ),
                        opts.GraphicText(
                            graphic_item=opts.GraphicItem(
                                left="center", top="center", z=100
                            ),
                            graphic_textstyle_opts=opts.GraphicTextStyleOpts(
                                text="第{}轮→马太效应".format(i),
                                font="bold 26px Microsoft YaHei",
                                graphic_basicstyle_opts=opts.GraphicBasicStyleOpts(
                                    fill="#fff"
                                ),
                            ),
                        ),
                    ],
                )
            ],
        )
    )
    tl.add(bar, "第{}轮".format(i))
tl.render("timeline_bar_with_graphic.html")
tl.render_notebook()
```


### 热力图

- [官方代码示例](https://gallery.pyecharts.org/#/Heatmap/heatmap_base)

```python
import random
from pyecharts import HeatMap

x_axis = [
    "12a", "1a", "2a", "3a", "4a", "5a", "6a", "7a", "8a", "9a", "10a", "11a",
    "12p", "1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p", "10p", "11p"]
y_axis = [
    "Saturday", "Friday", "Thursday", "Wednesday", "Tuesday", "Monday", "Sunday"]
data = [[i, j, random.randint(0, 50)] for i in range(24) for j in range(7)]
# ==== 旧版过程调用 =====
heatmap = HeatMap()
heatmap.add(
    "热力图直角坐标系",
    x_axis,
    y_axis,
    data,
    is_visualmap=True,
    visual_range=[0, 1], # 取值范围
    visual_range_color=["#CDC5BF","#FF69B4", "#FF0000"], # 颜色设置
    visual_text_color="#000",
    visual_orient="horizontal",
)
heatmap.render('heatmap.html')
heatmap.render_notebook()

# === 新版链式调用 ===
from pyecharts.charts import HeatMap

heatmap = (HeatMap()
            .add_xaxis(x_axis)
            .add_yaxis("发博数", y_axis, data)
            .set_global_opts(
                title_opts=opts.TitleOpts(title="用户发博时间热力图"),
                visualmap_opts=opts.VisualMapOpts(max_=600)
            )
    )

```

![](https://pic4.zhimg.com/50/v2-c775a724d9447266ec572725392edae8_hd.webp?source=1940ef5c)

【2021-8-22】实践，参考[官方教程](https://gallery.pyecharts.org/#/Heatmap/heatmap_on_cartesian)

```python
# y轴标签 intent_list，x轴便签slot_list，数据矩阵data
data = [[x,y,intent_slot_list[y][x]] for x in range(len(slot_list)) for y in range(len(intent_list))]
heat_map = (
    HeatMap(init_opts=opts.InitOpts(width="1440px", height="720px"))
    .add_xaxis(xaxis_data=slot_list)
    .add_yaxis(
        series_name="频次",
        yaxis_data=intent_list,
        value=data,
        label_opts=opts.LabelOpts(
            is_show=True, color="#fff", position="bottom", horizontal_align="50%"
        ),
    )
    .set_series_opts()
    .set_global_opts(
        title_opts=opts.TitleOpts(title="意图槽位分布图"),
        toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
        legend_opts=opts.LegendOpts(is_show=False),
        xaxis_opts=opts.AxisOpts(
            type_="category",
            splitarea_opts=opts.SplitAreaOpts(
                is_show=True, areastyle_opts=opts.AreaStyleOpts(opacity=1)
            ),
        ),
        yaxis_opts=opts.AxisOpts(
            type_="category",
            splitarea_opts=opts.SplitAreaOpts(
                is_show=True, areastyle_opts=opts.AreaStyleOpts(opacity=1)
            ),
        ),
        visualmap_opts=opts.VisualMapOpts(
            min_=1, max_=1000, is_calculable=True, orient="horizontal", pos_left="center"
        ),
    )
)
```

### 水球图

代码

```python
from pyecharts import options as opts
from pyecharts.charts import Liquid, Grid
from pyecharts.globals import SymbolType

c1 = (
    Liquid()
    .add("有效交互成功率", [0.75], 
    center=["15%", "50%"], # 多个图时，各自位置范围
    is_outline_show=False, # 边框不显示
    shape=SymbolType.RECT) # 水球形状（默认圆形，此处设置为矩形）
    #.add("有效交互成功率", [his_data[-1][-2]*0.01], center=["15%", "50%"])
    .set_global_opts(title_opts=opts.TitleOpts(title="比例值"))
    #.render("liquid_base.html")
)
```


### graph图谱

- 【2020-11-27】多轮转化图

```python
import random
import pyecharts as pe
# 为了避免显示空白，加入以下代码执行后，重新刷新当前jupyter页面即可
pe.configure(
    jshost="https://pyecharts.github.io/assets/js",
    echarts_template_dir=None,
    force_js_embed=None,
    output_image=None,
    global_theme=None
)
# 代码参考：http://pyecharts.org/#/zh-cn/charts_base?id=heatmap%EF%BC%88%E7%83%AD%E5%8A%9B%E5%9B%BE%EF%BC%89
# x_axis = ["12a", "1a", "2a", "3a", "4a", "5a", "6a", "7a", "8a", "9a", "10a", "11a",
#     "12p", "1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p", "10p", "11p"]
# y_axis = ["Saturday", "Friday", "Thursday", "Wednesday", "Tuesday", "Monday", "Sunday"]
# data = [[i, j, random.randint(0, 50)] for i in range(24) for j in range(7)]
page = pe.Page('多轮对话场景分析')
title = '投诉进度查询状态转化'
# (1) 节点状态转化图
x_axis = y_axis = attr_list
item_len = len(x_axis)
data = [[x_axis[i], y_axis[j], val_list[i][j]] for i in range(item_len) for j in range(item_len)]
heatmap = pe.HeatMap()
heatmap.add(
    '%s（x -> y）'%(title),
    x_axis,
    y_axis,
    data,
    is_visualmap=True,
    visual_range=[dh.get_values().min(), dh.get_values().max()],
    visual_text_color="#000",
    visual_orient="horizontal",
)
#heatmap.render()
page.add(heatmap)

# (2) Graph图谱
from pyecharts import Graph

# 定义节点
categories=[{}, {'name': '类目1'},{'name': '类目2'} # 节点类型
nodes = [{"name": "A", "symbolSize": 10, "category":2},
         {"name": "B", "symbolSize": 20, "category":2},
         {"name": "C", "symbolSize": 30, "category":1},
         {"name": "D", "symbolSize": 40, "category":2},
         {"name": "E", "symbolSize": 50, "category":1},
         {"name": "F", "symbolSize": 40, "category":2},
        # opts.GraphNode(name="所有交互", symbol_size=50, x=500, y=200), # 节点位置固定，与add里的layout='none'配合使用才生效
         { "name": "所有交互", "symbol_size": 50, "x":500, "y":200, "category":2), # 节点位置固定，与add里的layout='none'配合使用才生效
         {"name": "G", "symbolSize": 30, "category":1},
         {"name": "H", "symbolSize": 20, "category":2}]
# 定义边/链接
links = []
for i in nodes:
    for j in nodes:
        links.append({"source": i.get('name'), "target": j.get('name')})
nodes = json.loads(json.dumps(nodes))
# 图表
graph = Graph("%s-状态图"%(title))
# 添加节点/边
graph.add("", nodes, links, repulsion=80000, symbol='roundRect', 
    layout='force', # layout=none固定节点位置
    edgeSymbolSize= [0, 20], categories=categories,
    is_rotate_label=True, # 标签旋转
    formatter="{b}，数值为{c} ", # js显示数据格式，可用参数{a},{b},...,{e}
    linestyle_opts=opts.LineStyleOpts(color="source", curve=0.3), # 线型设置，curve=0.3表示弯曲程度
    edgeSymbol =['circle', 'arrow'])
#graph.render()
page.add(graph)
# 集中渲染到html文件
page.render('muti_turn_vis.html')
page

# (3) 自定义绘图 【2021-10-23】
from pyecharts import options as opts
from pyecharts.charts import Page, Tab
from pyecharts.charts import Graph

dt_info = '2021-10-23'
# 节点类型
categories=[{}, {'name': '所有交互'},{'name': '无效交互'},{'name': '有效交互'},{'name': '成功'},{'name': '失败'}]
# 边信息
trans_info = {'所有交互->有效交互': 120,
 '所有交互->无效交互': 189,
 '无效交互->环境杂音': 186,
 '无效交互->教学': 3,
 '有效交互->成功': 115,
 '有效交互->失败': 1,
 '失败->ASR错误': 1,
 '失败->新意图': 3,
 '失败->重复唤醒': 1,
 '失败->NLU泛化': 0,
 '成功->退出': 77,
 '成功->签约意图': 33,
 '成功->闲聊': 3,
 '成功->其它': 2}
# 节点信息
nodes = [
    #opts.GraphNode(name="所有交互", symbol_size=50), # 节点位置不定
    opts.GraphNode(name=f"所有交互\n{1000}", symbol_size=50, x=500, y=220, category=1, value=1000,
        label_opts=opts.LabelOpts(is_show=True, font_size='20', color='green') # 可以单独设置label格式
        ), # 节点位置固定，与add里的layout='none'配合使用才生效
    opts.GraphNode(name="无效交互", symbol_size=50, x=450, y=250, category=2, value=trans_info["所有交互->无效交互"]),
    opts.GraphNode(name="有效交互", symbol_size=50, x=550, y=250, category=3, value=trans_info["所有交互->有效交互"]),
    opts.GraphNode(name="失败", symbol_size=50, x=520, y=280, category=5, value=trans_info["有效交互->失败"]),
    opts.GraphNode(name="成功", symbol_size=50, x=580, y=280, category=4, value=trans_info["有效交互->成功"]),
    opts.GraphNode(name="环境杂音", symbol_size=30, x=380, y=310, category=2, value=trans_info["无效交互->环境杂音"]),
    opts.GraphNode(name="教学", symbol_size=30, x=400, y=310, category=2, value=trans_info["无效交互->教学"]),
    opts.GraphNode(name="退出", symbol_size=30, x=550, y=310, category=4, value=trans_info["成功->退出"]),
    opts.GraphNode(name="闲聊", symbol_size=30, x=570, y=310, category=4, value=trans_info["成功->闲聊"]),
    opts.GraphNode(name="签约意图", symbol_size=30, x=590, y=310, category=4, value=trans_info["成功->签约意图"]),
    opts.GraphNode(name="其它", symbol_size=30, x=610, y=310, category=4, value=trans_info["成功->其它"]),
    opts.GraphNode(name="重复唤醒", symbol_size=30, x=480, y=310, category=5, value=trans_info["失败->重复唤醒"]),
    opts.GraphNode(name="ASR错误", symbol_size=30, x=500, y=310, category=5, value=trans_info["失败->ASR错误"]),
    opts.GraphNode(name="NLU泛化", symbol_size=30, x=520, y=310, category=5, value=trans_info["失败->NLU泛化"]),
    opts.GraphNode(name="新意图", symbol_size=30, x=540, y=310, category=5, value=trans_info["失败->新意图"]),
]
# 【2021-11-2】 由于节点无法显示数值，只好在节点名中包含数值，这会影响边关联，所以需要单独获取node对象的名称
#      node.get('name') 获取节点名
nodes_name_dict = dict([[i.get('name').split('\n')[0], i.get('name')] for i in nodes])

# 逐个添加边(可忽略)
links = [
    opts.GraphLink(source="所有交互", target="无效交互", linestyle_opts=opts.LineStyleOpts(width=20, opacity=0.5)),
    opts.GraphLink(source="所有交互", target="有效交互", linestyle_opts=opts.LineStyleOpts(width=4, opacity=0.5)),
    opts.GraphLink(source="无效交互", target="环境杂音"),
    opts.GraphLink(source="无效交互", target="教学"),
    opts.GraphLink(source="有效交互", target="失败"),
    opts.GraphLink(source="有效交互", target="成功"),
    opts.GraphLink(source="失败", target="重复唤醒"),
    opts.GraphLink(source="失败", target="ASR错误"),
    opts.GraphLink(source="失败", target="NLU泛化"),
    opts.GraphLink(source="失败", target="新意图"),
    opts.GraphLink(source="成功", target="退出"),
    opts.GraphLink(source="成功", target="闲聊"),
    opts.GraphLink(source="成功", target="签约意图"),
    opts.GraphLink(source="成功", target="其它"),
]
# 或批量添加(提前准备trans_info字典)
links = []
for item in trans_info:
    s, d = item.split('->')
    width = max(int(trans_info[item]*30/df_sample.shape[0]), 1)
    links.append(opts.GraphLink(source=s, target=d, 
        # source=nodes_name_dict.get(s, f'异常-{s}'), 
        # target=nodes_name_dict.get(d, f'异常-{d}'), 
        value=round(trans_info[item]*100/1000,2),
        linestyle_opts=opts.LineStyleOpts(width=width, opacity=0.3)))
# 绘图
c = (
    Graph(init_opts=opts.InitOpts(width="1440px", height="720px"))
    .add("", nodes, links, repulsion=400, symbol='roundRect', layout='none',  # force
             symbol_size= [0, 20],edge_symbol =['circle', 'arrow'], is_draggable=True, categories=categories,
            is_rotate_label=True, # 标签旋转
            linestyle_opts=opts.LineStyleOpts(color="source", type_= 'dashed'),#'solid', 'dashed', 'dotted'
            label_opts=opts.LabelOpts(is_show=True, font_size='18', color='blue'), # 节点label
            edge_label=opts.LabelOpts(is_show=True, position="middle", # 边label
                font_size='15', formatter="{c}%") # {b} 是默认值：a>b
        )
    .set_global_opts(title_opts=opts.TitleOpts(title="签约大屏漏斗数据"))
    #.render("graph_with_options.html")
)
# make_snapshot(driver,g.render("gauge.html"),"gauge.png")
tab.add(c, '交互漏斗图')

tab.render(f'可视化-签约大屏城市流量分布{dt_info}.html')

```

参数设置：
- formatter模板变量[说明](https://pyecharts.org/#/zh-cn/series_options?id=labelopts%ef%bc%9a%e6%a0%87%e7%ad%be%e9%85%8d%e7%bd%ae%e9%a1%b9),{a},{b},...,{e}
- graph[示例](https://zhuanlan.zhihu.com/p/358471558)

```python
# 节点方法
class GraphNode(
    # 数据项名称。
    name: Optional[str] = None,
    # 节点的初始 x 值。在不指定的时候需要指明layout属性选择布局方式。
    x: Optional[Numeric] = None,
    # 节点的初始 y 值。在不指定的时候需要指明layout属性选择布局方式。
    y: Optional[Numeric] = None,
    # 节点在力引导布局中是否固定。
    is_fixed: bool = False,
    # 数据项值。
    value: Union[str, Sequence, None] = None,
    # 数据项所在类目的 index。
    category: Optional[int] = None,
    # 该类目节点标记的图形。
    # ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 
    # 'diamond', 'pin', 'arrow', 'none'
    # 可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI。
    symbol: Optional[str] = None,
    # 该类目节点标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示宽和高，
    # 例如 [20, 10] 表示标记宽为 20，高为 10。
    symbol_size: Union[Numeric, Sequence, None] = None,
    # 标签配置项，参考 `series_options.LabelOpts`
    label_opts: Optional[LabelOpts] = None,
)
# 节点分类
class GraphCategory(
    # 类目名称，用于和 legend 对应以及格式化 tooltip 的内容。
    name: Optional[str] = None,
    # 该类目节点标记的图形。
    # ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 
    # 'diamond', 'pin', 'arrow', 'none'
    # 可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI。
    symbol: Optional[str] = None,
    # 该类目节点标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示宽和高，
    # 例如 [20, 10] 表示标记宽为 20，高为 10。
    symbol_size: Union[Numeric, Sequence, None] = None,
    # # 标签样式，参考 `series_options.LabelOpts`
    label_opts: Optional[LabelOpts] = None,
)

# 边方法
class GraphLink(
    # 边的源节点名称的字符串，也支持使用数字表示源节点的索引。
    source: Union[str, int, None] = None,
    # 边的目标节点名称的字符串，也支持使用数字表示源节点的索引。
    target: Union[str, int, None] = None,
    # 边的数值，可以在力引导布局中用于映射到边的长度。
    value: Optional[Numeric] = None,
    # 边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。
    symbol: Union[str, Sequence, None] = None,
    # 边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。
    symbol_size: Union[Numeric, Sequence, None] = None,
    # 关系边的线条样式，参考 `series_options.LineStyleOpts`
    linestyle_opts: Optional[LineStyleOpts] = None,
    # 标签样式，参考 `series_options.LabelOpts`
    label_opts: Optional[LabelOpts] = None,
)

# add方法
def add(
    # 系列名称，用于 tooltip 的显示，legend 的图例筛选。
    series_name: str,
    # 关系图节点数据项列表，参考 `opts.GraphNode`
    nodes: Sequence[Union[opts.GraphNode, dict]],
    # 关系图节点间关系数据项列表，参考 `opts.GraphLink`
    links: Sequence[Union[opts.GraphLink, dict]],
    # 关系图节点分类的类目列表，参考 `opts.GraphCategory`
    categories: Union[Sequence[Union[opts.GraphCategory, dict]], None] = None,
    # 是否选中图例。
    is_selected: bool = True,
    # 是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点。
    is_focusnode: bool = True,
    # 是否开启鼠标缩放和平移漫游。
    is_roam: bool = True,
    # 节点是否可拖拽，只在使用力引导布局的时候有用。
    is_draggable: bool = False,
    # 是否旋转标签，默认不旋转。
    is_rotate_label: bool = False,
    # ==== 图的布局 ====== 可选：
    # 'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。
    # 'circular' 采用环形布局。
    # 'force' 采用力引导布局。
    layout: str = "force",
    # 关系图节点标记的图形。
    # ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 
    # 'diamond', 'pin', 'arrow', 'none'
    # 可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI。
    symbol: Optional[str] = None,
    # 关系图节点标记的大小
    # 可以设置成诸如 10 这样单一的数字
    # 也可以用数组分开表示宽和高，例如 [20, 10] 表示标记宽为20，高为10。
    symbol_size: types.Numeric = 10,
    # 边的两个节点之间的距离，这个距离也会受 repulsion。
    # 支持设置成数组表达边长的范围，此时不同大小的值会线性映射到不同的长度。值越小则长度越长。
    edge_length: Numeric = 50,
    # 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。
    gravity: Numeric = 0.2,
    # 节点之间的斥力因子。
    # 支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大
    repulsion: Numeric = 50,
     # Graph 图节点边的 Label 配置（即在边上显示数据或标注的配置）
    edge_label: types.Label = None,
    # 边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。
    # 默认不显示标记，常见的可以设置为箭头，如下：edgeSymbol: ['circle', 'arrow']
    edge_symbol: Optional[str] = None,
    # 边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。
    edge_symbol_size: Numeric = 10,
    # 标签配置项，参考 `series_options.LabelOpts`
    label_opts: Union[opts.LabelOpts, dict] = opts.LabelOpts(),
    # 关系边的公用线条样式。
    linestyle_opts: Union[opts.LineStyleOpts, dict] = opts.LineStyleOpts(),
    # 提示框组件配置项，参考 `series_options.TooltipOpts`
    tooltip_opts: Union[opts.TooltipOpts, dict, None] = None,
    # 图元样式配置项，参考 `series_options.ItemStyleOpts`
    itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] = None,
)
```

### 3D散点图

散点图维度绘制时，注意数轴类型，默认只把Z轴当数值，其余轴当做离散类目处理，因此会出现x、y轴数值失效的情形，此时需要单独设置x和y轴的类型。
- 注意：【2021-8-19】2D和3D设置方法不同！
- 

代码：适用于1.*以上版本

```python
import random
from pyecharts import options as  opts
#from pyecharts.charts import Scatter # 2D散点图
from pyecharts.charts import Scatter3D
from pyecharts.faker import Faker

N = 50
label = range(N)
# 数据点格式：[x,y,z,label],默认取前面数据当坐标，后面作为其他信息
Scatter_data = [(random.randint(0,N),random.randint(0,N),random.randint(0,N)) for i in range(N)]

c = (
    Scatter3D(init_opts = opts.InitOpts(width='900px',height='600px'))  #初始化
    .add("",Scatter_data,
        xaxis3d_opts=opts.Axis3DOpts(type_='value'), # 3D散点图x轴类型设置
        yaxis3d_opts=opts.Axis3DOpts(type_='value'), # 3D散点图y轴类型设置
        grid3d_opts=opts.Grid3DOpts(width=100, depth=100, rotate_speed=100, is_rotate=True)
    )
    #设置全局配置项
    .set_global_opts(
        title_opts=opts.TitleOpts(title="3D散点图"),  #添加标题
        visualmap_opts=opts.VisualMapOpts(
            max_=50, #最大值
            pos_top=50, # visualMap 组件离容器上侧的距离
            dimension=2, # 按第三(2+1)个维度取值范围来标颜色
            range_size=[10, 40], # 数据点大小
            range_color=Faker.visual_color  #颜色映射                                         
        ),
        #xaxis_opts=opts.AxisOpts(type_='value'), # 2D散点图设置数值
        #yaxis_opts=opts.AxisOpts(type_='value'),# 2D散点图设置数值
        #zaxis_opts=opts.AxisOpts(type_='value') # category
    )
)
c.render("3D散点图.html") # 保存到文件
c.render_notebook() # 输出到jupyter notebook页面
```

效果示例：

![](https://img-blog.csdnimg.cn/20210615152659376.png)


### 雷达图

打分信息可视化

```python
from pyecharts import options as opts
from pyecharts.charts import Radar

v1 = [(4300, 10000, 28000, 35000, 50000, 19000)]
v2 = [(5000, 14000, 28000, 31000, 42000, 21000)]
p = Radar().add_schema(
            schema=[
                opts.RadarIndicatorItem(name="销售", max_=6500),
                opts.RadarIndicatorItem(name="管理", max_=16000),
                opts.RadarIndicatorItem(name="信息技术", max_=30000),
                opts.RadarIndicatorItem(name="客服", max_=38000),
                opts.RadarIndicatorItem(name="研发", max_=52000),
                opts.RadarIndicatorItem(name="市场", max_=25000),
            ]
        ) \
        .add("预算分配", v1)\
        .add("实际开销", v2)\
        .set_series_opts(label_opts=opts.LabelOpts(is_show=False))
p.render('radar.html')
p.render_notebook()
```

应用

```python
import pyecharts as pe

s = {'score':[[]], 'name_cn':[], 'full_score':[]}
for i in data['factor_score']:
    s['score'][0].append(i['score'])
    s['name_cn'].append(i['name_cn'])
    s['full_score'].append(i['ref_score']['full_score'])
print(s)
print(data['total_score']['score'])
print([(s['name_cn'][i],s['full_score'][i],s['score'][i]) for i in range(len(s['score']))])
c = pe.charts.Radar()
opt = pe.options

c.add_schema(
        #schema= [ opt.RadarIndicatorItem(name=s['name_cn'][i], max_=s['full_score'][i]) for i in range(len(s['score']))]
        schema = [
            opt.RadarIndicatorItem(name=s['name_cn'][0], max_=s['full_score'][0]),
            opt.RadarIndicatorItem(name=s['name_cn'][1], max_=s['full_score'][1]),
            opt.RadarIndicatorItem(name=s['name_cn'][2], max_=s['full_score'][2]),
            opt.RadarIndicatorItem(name=s['name_cn'][3], max_=s['full_score'][3]),
            opt.RadarIndicatorItem(name=s['name_cn'][4], max_=s['full_score'][4]),
            opt.RadarIndicatorItem(name=s['name_cn'][5], max_=s['full_score'][5]),
            opt.RadarIndicatorItem(name=s['name_cn'][6], max_=s['full_score'][6]),
            opt.RadarIndicatorItem(name=s['name_cn'][7], max_=s['full_score'][7]),
        ]
    ).add("评分你好", s['score']) \
    .set_series_opts(label_opts=pe.options.LabelOpts(is_show=True))
#.add("预算分配", v1).add("实际开销", v2) \
c.render('radar.html')
c.render_notebook() 
```

### 地图数据

pyecharts有地理有几类：
- （1）Geo：地理坐标可视化，点形式
- （2）Map：矢量图形式，分成2D和3D
- （3）BMap：百度地图形式

基础数据：
- 全球国家地图: echarts-countries-pypkg ：世界地图和 213 个国家，包括中国地图
- 中国省级地图: echarts-china-provinces-pypkg ：23 个省，5 个自治区
- 中国市级地图: echarts-china-cities-pypkg ：370 个中国城市
- 中国县区级地图: echarts-china-counties-pypkg ：2882 个中国县、区
- 中国区域地图: echarts-china-misc-pypkg ：11 个中国区域地图，比如华南、华北。

安装：

```shell
pip install echarts-countries-pypkg
pip install echarts-china-provinces-pypkg
pip install echarts-china-cities-pypkg
pip install echarts-china-counties-pypkg
pip install echarts-china-misc-pypkg
```

【2021-8-31】中国地理行政区划数据：省份、城市、区划数据，json格式：

```shell
!wget https://github.com/nixing87/area/blob/main/json/all_province_with_adcode_key.json
!wget https://github.com/nixing87/area/blob/main/json/all_city_with_adcode_key.json
```

- 各省份信息

```s
省份 简称 省会 东经 北纬
安徽 皖 合肥 117.194778,31.86577
北京 京 　 116.403694,39.949459
重庆 渝 　 　 116.403694,39.949459
福建 闽 　 福州 119.292069,26.144144
甘肃 甘 　 兰州 103.856737,36.094212
广东 粤 　 广州 113.239359,23.185545
广西 桂 　 南宁 108.345678,22.861984
贵州 黔 　 贵阳 106.616332,26.707352
海南 琼 　 海口 110.350983,19.968035
河北 冀 　 石家庄 114.508772,38.083783
河南 豫 　 郑州 113.644099,34.769161
黑龙江 黑 哈尔滨 126.522207,45.801617
湖北 鄂 　 武汉 114.361594,30.601078
湖南 湘 　 长沙 112.926605,28.217167
吉林 吉 　 长春 125.326383,43.797768
江苏 苏 　 南京 118.832137,32.038322
江西 赣 　 南昌 115.851775,28.672488
辽宁 辽 　 沈阳 123.486653,41.682522
内蒙古 蒙 呼和浩特 111.785972,40.849642
宁夏 宁 　 银川 106.257585,38.482579
青海 青 　 西宁 101.851432,36.622494
山东 鲁 　 济南 117.194778,36.652148
山西 晋 　 太原 112.595453,37.858034
陕西 陕 　 西安 109.026378,34.350591
上海 沪 　 　 121.518142,31.211845
四川 川 　 成都 104.132697,30.561282
天津 津 　 　 117.286764,39.001295
西藏 藏 　 拉萨 91.144205,29.649484
新疆 新 　 乌鲁木齐 87.667116,43.817754
云南 滇 　 昆明 102.881681,24.866897
浙江 浙 　 杭州 120.211934,30.274265
香港 港 　 　 114.242011,22.272474
澳门 澳 　 　 113.579709,22.169692
台湾 台 　 台北 121.591732,25.034634
```

#### 省份数据抽取

【2021-10-21】[cpca](https://github.com/DQinYuan/chinese_province_city_area_mapper)库用于提取简体中文字符串中省/市/区信息并能够进行映射，检验和简单绘图的python模块。简单来说就是文本出现的市区名称转换为省份名称。
- pip install cpca
- ![](https://user-images.githubusercontent.com/23725000/39467901-0471419a-4d63-11e8-92fd-63bab219a766.png)

```python
#!pip install cpca
# cpca是chinese province city area的缩写
# https://github.com/DQinYuan/chinese_province_city_area_mapper
location_str = ["徐汇区虹漕路461号58号楼5楼", "泉州市洛江区万安塘西工业区", "北京朝阳区北苑华贸城"]
import cpca
df = cpca.transform(location_str)
# 显示提取位置，大于-1的部分就代表提取的位置。-1则表明这个字段是靠程序推断出来的，或者没能提取出来。
#df = cpca.transform(location_str, pos_sensitive=True)
df
#   省     市    区          地址              adcode
# 0 上海市 上海市  徐汇区     虹漕路461号58号楼5楼  310104
# 1 福建省 泉州市  洛江区     万安塘西工业区        350504
# 2 北京市 市辖区  朝阳区     北苑华贸城           110105
# ------ 消歧 -------
cpca.transform(["朝阳区汉庭酒店大山子店"])
#     省    市    区        地址  adcode
#0  吉林省  长春市  朝阳区  汉庭酒店大山子店  220104
cpca.transform(["朝阳区汉庭酒店大山子店"],umap={"朝阳区":"110105"})
#     省    市    区        地址  adcode
#0  北京市  市辖区  朝阳区  汉庭酒店大山子店  110105
# ------- 长文本提取 --------
df = cpca.transform_text_with_addrs("分店位于徐汇区虹漕路461号58号楼5楼和泉州市洛江区万安塘西工业区以及南京鼓楼区")

# 自带的绘图工具 folium（速度慢），热力图显示
#pip install folium
from cpca import drawer
#df为上一段代码输出的df
drawer.draw_locations(df, "df.html")
# 改用echarts
#pip install pyecharts==0.5.11
#pip install echarts-countries-pypkg
#pip install pyecharts-snapshot
from cpca import drawer
drawer.echarts_draw(processed[cpca._ADCODE], "echarts.html")
drawer.echarts_cate_draw(processed[cpca._ADCODE], processed["省"], "echarts_cate.html")
```

#### 平面地图

热力图形式, maptype
- 国家名：世界各国地图，如：瑞士
- china: 省
- china

[官方示例](https://gallery.pyecharts.org/#/Geo/geo_echart_china_js)

```python
# ---------- 世界地图（瑞士）--------
from pyecharts import options as opts
from pyecharts.charts import Geo
from pyecharts.datasets import register_url

try:
    register_url("https://echarts-maps.github.io/echarts-countries-js/")
except Exception:
    import ssl

    ssl._create_default_https_context = ssl._create_unverified_context
    register_url("https://echarts-maps.github.io/echarts-countries-js/")

geo = (
    Geo()
    .add_schema(maptype="瑞士")
    .set_global_opts(title_opts=opts.TitleOpts(title="瑞士"))
    .render("geo_chart_countries_js.html")
)

# ---------- 中国各省份 --------
from pyecharts import options as opts
from pyecharts.charts import Geo # 地理坐标信息
from pyecharts.faker import Faker
from pyecharts.globals import ChartType # 图表类型

c = (
    Geo()
    .add_schema(maptype="china") # maptype=china（省），maptype="广东"，maptype="海淀区"
    .add(
        "geo",
        [list(z) for z in zip(Faker.provinces, Faker.values())],
         # 图表类型，默认静态点
        type_=ChartType.HEATMAP, # 这里设置为热力图
        # type_=ChartType.EFFECT_SCATTER # 波纹点
        label_opts=opts.LabelOpts(), # 显示省份名称
    )
    .set_series_opts(label_opts=opts.LabelOpts(is_show=False))
    .set_global_opts(
        visualmap_opts=opts.VisualMapOpts(),
        #visualmap_opts=opts.VisualMapOpts(is_piecewise=True), # 图例自动分段
        title_opts=opts.TitleOpts(title="Geo-HeatMap"),
    )
)
# ---------- 城市地图 --------
from pyecharts import options as opts
from pyecharts.charts import Map
from pyecharts.faker import Faker

tmp_data = [[i[0],i[1]] for i in table_data] # [[北京,10],[上海,20]]
m = (
    Map(init_opts=opts.InitOpts(width="1440px", height="720px"))
    .add("各城市热度", tmp_data, "china-cities",
        label_opts=opts.LabelOpts(is_show=False),
    )
    .set_global_opts(
        title_opts=opts.TitleOpts(title="各城市PV分布({dt_info})"),
        visualmap_opts=opts.VisualMapOpts(max_=max([i[1] for i in tmp_data]), is_piecewise=True),
        toolbox_opts=opts.ToolboxOpts(is_show=True), # 工具箱
    )
    #.render("map_china_cities.html")
)
# ---------- 区地图 --------
from pyecharts import options as opts
from pyecharts.charts import Geo
from pyecharts.datasets import register_url

try:
    register_url("https://echarts-maps.github.io/echarts-china-counties-js/")
except Exception:
    import ssl

    ssl._create_default_https_context = ssl._create_unverified_context
    register_url("https://echarts-maps.github.io/echarts-china-counties-js/")

geo = (
    Geo()
    .add_schema(maptype="海淀区")
    .set_global_opts(title_opts=opts.TitleOpts(title="海淀区"))
    .render("geo_echart_china_js.html")
)
# ---------- 动态迁移图 --------
from pyecharts import options as opts
from pyecharts.charts import Geo
from pyecharts.globals import ChartType, SymbolType

c = (
    Geo()
    .add_schema(maptype="china")
    .add( # 城市数据
        "",
        [("广州", 55), ("北京", 66), ("杭州", 77), ("重庆", 88)],
        type_=ChartType.EFFECT_SCATTER, # 点展示形式
        color="white",
    )
    .add( # 迁移数据
        "geo",
        [("广州", "上海"), ("广州", "北京"), ("广州", "杭州"), ("广州", "重庆")],
        type_=ChartType.LINES, # 箭头形式展示
        effect_opts=opts.EffectOpts(
            symbol=SymbolType.ARROW, symbol_size=6, color="blue"
        ),
        linestyle_opts=opts.LineStyleOpts(curve=0.2),
    )
    .set_series_opts(label_opts=opts.LabelOpts(is_show=False))
    .set_global_opts(title_opts=opts.TitleOpts(title="Geo-Lines"))
    .render("geo_lines.html")
)

```


#### 可视化案例

- [Pyecharts绘制可视化地图专辑-星巴克门店分析](https://jishuin.proginn.com/p/763bfbd5b04d)
- 【2021-10-21】[用Python带你看豆瓣上征婚交友的小姐姐们](https://www.toutiao.com/i7021343625829253644/)
- 分析：
  - 豆瓣上居然还有一个叫我被豆油表白了的交友话题，阅读量居然高达 8087734 次，拥有 1000+ 篇话题，几乎每篇平均被阅读了 8000+ ，看了一下里面的小姐姐照片还挺多的。
  - 华东和华南交友的小姐姐要比华北和西部的小姐姐多很多，看起来单身小姐姐都集中在一线城市及其周边。
  - ![](https://p26.toutiaoimg.com/origin/pgc-image/f77524d34ca548e193bb1027257f6bba?from=pc)
代码

```python
url_basic = 'https://m.douban.com/rexxar/api/v2/gallery/topic/18306/items?from_web=1&sort=hot&start={}&count=20&status_full_text=1&guest_only=0&ck=GStY'
headers = { 
    'Accept': 'application/json, text/javascript, */*; q=0.01',
    'Accept-Encoding': 'gzip, deflate, br',
    'Accept-Language': 'zh-CN,zh;q=0.9',
    'Connection': 'keep-alive',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Cookie': 'bid=n7vzKfXLoUA; douban-fav-remind=1; ll="108296"; __utmc=30149280; __utmz=30149280.1624276858.2.2.utmcsr=google|utmccn=(organic)|utmcmd=organic|utmctr=(not%20provided); ap_v=0,6.0; gr_user_id=ca8b9156-1926-4c82-9dda-27fc7f7ad51b; __utma=30149280.66080894.1623848440.1624276858.1624282580.3; __utmt=1; dbcl2="157316158:e4ojS8paSUc"; ck=GStY; push_doumail_num=0; __utmv=30149280.15731; frodotk="a187943e3a17e8bbe496bcbaae47ba31"; push_noty_num=0; __utmb=30149280.11.10.1624282580',
    'Host': 'm.douban.com',
    'Origin': 'https://www.douban.com',
    'Referer': 'https://www.douban.com/gallery/topic/18306/',
    'sec-ch-ua': '" Not;A Brand";v="99", "Google Chrome";v="91", "Chromium";v="91"',
    'sec-ch-ua-mobile': '?0',
    'Sec-Fetch-Dest': 'empty',
    'Sec-Fetch-Mode': 'cors',
    'Sec-Fetch-Site': 'same-site',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36'
}
# 获取地理位置信息
for i in range(1,35):
  res = requests.get(url=url_basic.format(i * 20), headers=headers)
  res_json = json.loads(res.text)
  index = 0
  for item in res_json.get('items'):
    target = item.get('target')
    status = target.get('status')
    print("这里是第 {} 个".format((i - 1) * 20 + index));
    index = index + 1
    with open('douban.txt', 'a+') as f:
      f.write(json.dumps(status) + '\n');  
  sleeptime=random.randint(1, 10)
  time.sleep(sleeptime)
# ---------- 下载图片信息 -----------
for line in file_object:
    item = json.loads(line)
    if item == None:
        continue
    images = item['images']
    id = item['id']

    index = 0
    for i in images:
        index = index + 1
        url = i.get('large').get('url')
        r = requests.get(url);
        with open('./image/{}-{}.jpg'.format(id, index), 'wb') as f:
            f.write(r.content) 

# --------- 地图可视化 --------------
from pyecharts.charts import Geo
from pyecharts.globals import ChartType

addr_dic = {}
file_object = open('douban.txt','r')
try:
    for line in file_object:
        item = json.loads(line)
        if item == None:
            continue
        author = item['author']
        text = item['text']
        addr_transform = cpca.transform([text])
        addr = None

        if addr_transform['省'].str.split(' ')[0] != None:
            addr = addr_transform['省'].str.split(' ')[0][0].rstrip('省')
        #这里提取创作者里面的地址
        if addr is None and author['loc'] is not None:
            cpca.transform([author['loc']['name']])

            if addr_transform['省'].str.split(' ')[0] != None:
                addr = addr_transform['省'].str.split(' ')[0][0].rstrip('省')
        #这个地址要转换一下，不然 echarts 不认
        if addr is not None:
            if addr == '广西壮族自治区':
                addr = '广西'
            if addr == '香港特别行政区':
                addr = '香港'
            if addr == '澳门特别行政区':
                addr = '澳门'
        addr_dic[addr] = addr_dic.get(addr, 0) + 1

finally:
    file_object.close()

# 小姐姐热力图
(
    Geo()
    .add_schema(maptype="china")
    .add(
        "",
        [list(z) for z in zip(list(addr_dic.keys()), list(addr_dic.values()))],
        type_=ChartType.HEATMAP,
    )
    .set_series_opts(label_opts=opts.LabelOpts(is_show=False))
    .set_global_opts(
        visualmap_opts=opts.VisualMapOpts(),
    ).render("热力图.html")
  )

# -------- 词云可视化 ----------
import jieba
from collections import Counter
from pyecharts.charts import WordCloud

for line in file_object:
    item = json.loads(line)
    if item == None:
        continue
    text = item['text']

    seg_list = jieba.cut(text, cut_all=False)
    text_list.extend(seg_list)

# 词频统计,使用Count计数方法
words_counter = Counter(text_list)
# 将Counter类型转换为列表
words_list = words_counter.most_common(500)
(
    WordCloud()
    .add(series_name="", data_pair=words, word_size_range=[20, 66])
    .render("词云.html")
)

```


#### 二维显示

- 平面显示
![](https://img-blog.csdnimg.cn/20210826111622243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAbGhhc19kZmdoamts,size_28,color_FFFFFF,t_70,g_se,x_16)

全国地图——省份

```python
from pyecharts import options as opts
from pyecharts.globals import ThemeType
from pyecharts.charts import Map#主题

# 省会及直辖市
data = [['江苏', 492], ['安徽', 830], ['湖南', 879], ['河南', 1073], ['浙江', 1092], ['广东', 1151], ['天津', 94], ['内蒙古', 58],
        ['北京', 337], ['陕西', 213], ['广西', 210], ['宁夏', 49], ['贵州', 109], ['上海', 295], ['江西', 771], ['福建', 261],
        ['新疆', 49], ['四川', 405], ['云南', 141], ['海南', 136], ['山东', 459], ['吉林', 80], ['黑龙江', 331], ['河北', 218],
        ['香港', 36], ['重庆', 468], ['山西', 119], ['甘肃', 83], ['湖北', 29631], ['辽宁', 107], ['台湾', 18], ['澳门', 10],
        ['青海', 18], ['西藏', 1]]

# 方法一 设置地图参数
map = (
    Map(init_opts=opts.InitOpts(bg_color="#FFFAFA", theme=ThemeType.ESSOS,width=1000))
        .add("确诊人数", data)
        .set_global_opts(
        title_opts=opts.TitleOpts(title="fungis-基于丁香园数据的疫情图"),
        # visualmap_opts=opts.VisualMapOpts(max_=2000),#使用系统默认label，最大区间值，因图而异
        visualmap_opts=opts.VisualMapOpts( # 定制label区间、名称
            is_piecewise=True,  # 设置是否为分段显示
            # 自定义的每一段的范围，以及每一段的文字，以及每一段的特别的样式。例如：
            pieces=[
                {"min": 2000, "label": '>2000人', "color": "#eb2f06"},
                {"min": 1000, "max": 2000, "label": '1001-2000人', "color": "#FF3030"},  # 不指定 max，表示 max 为无限大（Infinity）。
                {"min": 500, "max": 1000, "label": '500-1000人', "color": "#FF4500"},
                {"min": 100, "max": 499, "label": '100-499人', "color": "#FF7F50"},
                {"min": 10, "max": 99, "label": '10-99人', "color": "#FFA500"},
                {"min": 1, "max": 9, "label": '1-9人', "color": "#FFDEAD"},
            ],
            # 两端的文本，如['High', 'Low']。
            range_text=['高', '低'],
        )
    )
)
map.render(path="./html/中国疫情人数区间地图1.html")
```

城市区县地图

```python
from pyecharts.charts import Map
from pyecharts import options as opts
from pyecharts.globals import ThemeType  # 主题

# 各个城市相关数据
data = [['信阳市', 220], ['南阳市', 134], ['郑州市', 130], ['驻马店市', 123], ['商丘市', 83], ['周口市', 65], ['平顶山市', 52], ['新乡市', 46],
        ['安阳市', 45], ['许昌市', 31], ['漯河市', 30], ['洛阳市', 27], ['焦作市', 25], ['开封市', 24], ['鹤壁市', 17], ['濮阳市', 10],
        ['三门峡市', 7], ['济源市', 4]]
cityName = ['信阳市', '南阳市', '郑州市', '驻马店市', '商丘市', '周口市', '平顶山市', '新乡市', '安阳市', '许昌市', '漯河市', '洛阳市', '焦作市', '开封市', '鹤壁市',
            '濮阳市', '三门峡市', '济源市']
confirmedCount = [220, 134, 130, 123, 83, 65, 52, 46, 45, 31, 30, 27, 25, 24, 17, 10, 7, 4]
curedCount = [28, 28, 34, 14, 9, 11, 12, 6, 10, 2, 6, 2, 1, 1, 3, 0, 3, 0]
deadCount = [0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

map = (
    # 初始化配置项中可以设置画布宽高，背景色和主题
    Map(init_opts=opts.InitOpts(bg_color="#FFFAFA", theme=ThemeType.ROMANTIC, width=1000))
        .add("确诊人数", data, "河南", is_map_symbol_show=False, 
            # 【2021-9-1】地图上显示数值
            label_opts=opts.LabelOpts(
                is_show=True,
                formatter=JsCode("function(data){return data.value;}"),
            ),
        )  # 设置是否显示地图上的小红点
        .set_global_opts(
        # 标题配置项，pos_left可取值center、left、right、5%等等
        title_opts=opts.TitleOpts(title="河南疫情确诊人数分布图-fungis", pos_left="left"),
        visualmap_opts=opts.VisualMapOpts(
            is_piecewise=True,  # 设置是否为分段显示
            # 自定义的每一段的范围，以及每一段的文字，以及每一段的特别的样式。例如：
            pieces=[
                {"min": 201, "label": '>200人', "color": "#e55039"},  # 不指定 max，表示 max 为无限大（Infinity）。
                {"min": 101, "max": 200, "label": '101-200人', "color": "#FF4500"},
                {"min": 51, "max": 100, "label": '51-100人', "color": "#FF7F50"},
                {"min": 10, "max": 50, "label": '10-50人', "color": "#FFA500"},
                {"min": 1, "max": 9, "label": '1-9人', "color": "#FFDEAD"},
            ],
            # 两端的文本，如['High', 'Low']。
            range_text=['高', '低'],
        ),
    )
)
map.render(path="./河南疫情确诊人数分布图1.html")
```

#### 三维显示


[利用Python绘制酷炫的3D地图](https://blog.csdn.net/weixin_43413451/article/details/114697829)

坐标点数据

```python
from pyecharts import options as opts
from pyecharts.charts import Geo
from pyecharts.faker import Faker

c = (
    Geo()
    .add_schema(maptype="china")
    .add("geo", [list(z) for z in zip(Faker.provinces, Faker.values())])
    .set_series_opts(label_opts=opts.LabelOpts(is_show=False))
    .set_global_opts(
        visualmap_opts=opts.VisualMapOpts(), title_opts=opts.TitleOpts(title="Geo-基本示例")
    )
    #.render("geo_base.html")
)
c.render_notebook()
```

3D全国地图, 包含34个省市自治区数据

```python
from pyecharts import options as opts
from pyecharts.charts import Map3D
from pyecharts.globals import ChartType
from pyecharts.commons.utils import JsCode
 
example_data = [
    ("北京", [116.4036, 39.9494, 100]),
    ("黑龙江", [127.9688, 45.368, 100]),
    ("内蒙古", [110.3467, 41.4899, 300]),
    ("吉林", [125.8154, 44.2584, 300]),
    ("辽宁", [123.1238, 42.1216, 300]),
    ("河北", [114.4995, 38.1006, 300]),
    ("天津", [117.4219, 39.4189, 300]),
    ("山西", [112.3352, 37.9413, 300]),
    ("陕西", [109.1162, 34.2004, 300]),
    ("甘肃", [103.5901, 36.3043, 300]),
    ("宁夏", [106.3586, 38.1775, 300]),
    ("青海", [101.4038, 36.8207, 300]),
    ("新疆", [87.9236, 43.5883, 300]),
    ("西藏", [91.11, 29.97, 300]),
    ("四川", [103.9526, 30.7617, 300]),
    ("重庆", [108.384366, 30.439702, 300]),
    ("山东", [117.1582, 36.8701, 300]),
    ("河南", [113.4668, 34.6234, 300]),
    ("江苏", [118.8062, 31.9208, 300]),
    ("安徽", [117.29, 32.0581, 300]),
    ("湖北", [114.3896, 30.6628, 300]),
    ("浙江", [119.5313, 29.8773, 300]),
    ("福建", [119.4543, 25.9222, 300]),
    ("江西", [116.0046, 28.6633, 300]),
    ("湖南", [113.0823, 28.2568, 300]),
    ("贵州", [106.6992, 26.7682, 300]),
    ("广西", [108.479, 23.1152, 300]),
    ("海南", [110.3893, 19.8516, 300]),
    ("上海", [121.4648, 31.2891, 300]),
    ("云南", [102.8816, 24.8668, 100]), # 昆明
    ("广东", [121.4648, 31.2891, 100]), # 广州
    ("香港", [114.2420, 22.2724, 100]),
    ("澳门", [113.5797, 22.1696, 100]),
    ("台湾", [121.5917, 25.0346, 100]), # 台北
]
 
c = (
    Map3D(init_opts=opts.InitOpts(width="1400px", height="700px"))
    .add_schema(
        itemstyle_opts=opts.ItemStyleOpts(
            color="rgb(5,101,123)",
            opacity=1,
            border_width=0.8,
            border_color="rgb(62,215,213)",
        ),
        map3d_label=opts.Map3DLabelOpts(
            is_show=False,
            formatter=JsCode("function(data){return data.name + " " + data.value[2];}"),
        ),
        emphasis_label_opts=opts.LabelOpts(
            is_show=False,
            color="#fff",
            font_size=10,
            background_color="rgba(0,23,11,0)",
        ),
        light_opts=opts.Map3DLightOpts(
            main_color="#fff",
            main_intensity=1.2,
            main_shadow_quality="high",
            is_main_shadow=False,
            main_beta=10,
            ambient_intensity=0.3,
        ),
    )
    .add(
        series_name="柱形图数据",
        data_pair=example_data,
        type_=ChartType.BAR3D, # 柱形图显示
        # type_=ChartType.SCATTER3D, # 散点图显示
        bar_size=1,
        shading="lambert",
        label_opts=opts.LabelOpts(
            is_show=False,
            formatter=JsCode("function(data){return data.name + ' ' + data.value[2];}"),
        ),
    )
    .set_global_opts(title_opts=opts.TitleOpts(title="城市数据"))
    #
)
c.render("带有数据展示地图.html")
c.render_notebook()
```

世界地图-3D

```python
import pyecharts.options as opts
from pyecharts.charts import MapGlobe
from pyecharts.faker import POPULATION
 
data = [x for _, x in POPULATION[1:]]
low, high = min(data), max(data)
 
c = (
    MapGlobe(init_opts=opts.InitOpts(width="1400px", height="700px"))
    .add_schema()
    .add(
        maptype="world",
        series_name="World Population",
        data_pair=POPULATION[1:],
        is_map_symbol_show=False,
        label_opts=opts.LabelOpts(is_show=False),
    )
    .set_global_opts(
        visualmap_opts=opts.VisualMapOpts(
            min_=low,
            max_=high,
            range_text=["max", "min"],
            is_calculable=True,
            range_color=["lightskyblue", "yellow", "orangered"],
        )
    )
)
c.render("地球.html")
#c.render_notebook()
```


### 三维数据函数可视化

示例：

```python
import math
from typing import Union

import pyecharts.options as opts
from pyecharts.charts import Surface3D

"""
Gallery 使用 pyecharts 1.1.0
参考地址: https://echarts.apache.org/examples/editor.html?c=surface-wave&gl=1

目前无法实现的功能:

1、暂时无法设置光滑表面 wireframe
2、暂时无法把 visualmap 进行隐藏
"""


def float_range(start: int, end: int, step: Union[int, float], round_number: int = 2):
    """
    浮点数 range
    :param start: 起始值
    :param end: 结束值
    :param step: 步长
    :param round_number: 精度
    :return: 返回一个 list
    """
    temp = []
    while True:
        if start < end:
            temp.append(round(start, round_number))
            start += step
        else:
            break
    return temp


def surface3d_data():
    for t0 in float_range(-3, 3, 0.05):
        y = t0
        for t1 in float_range(-3, 3, 0.05):
            x = t1
            z = math.sin(x ** 2 + y ** 2) * x / 3.14
            yield [x, y, z]


(
    Surface3D(init_opts=opts.InitOpts(width="1600px", height="800px"))
    .add(
        series_name="",
        shading="color",
        data=list(surface3d_data()),
        xaxis3d_opts=opts.Axis3DOpts(type_="value"),
        yaxis3d_opts=opts.Axis3DOpts(type_="value"),
        grid3d_opts=opts.Grid3DOpts(width=100, height=40, depth=100),
    )
    .set_global_opts(
        visualmap_opts=opts.VisualMapOpts(
            dimension=2,
            max_=1,
            min_=-1,
            range_color=[
                "#313695",
                "#4575b4",
                "#74add1",
                "#abd9e9",
                "#e0f3f8",
                "#ffffbf",
                "#fee090",
                "#fdae61",
                "#f46d43",
                "#d73027",
                "#a50026",
            ],
        )
    )
    .render("surface_wave.html")
)
```


# [smartchart](https://github.com/JohnYan2017/Echarts-Django)

- 【2021-1-2】[smartchart](https://www.smartchart.cn/blog/article/2019/6/1/3.html)
- 安装

```shell
#安装SmartChart
pip3 install smartchart
pip3 install smartchart -U #(升级)
# 如果安装过程慢,建意使用
pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple smartchart
#如果你是第一次安装SmartChart(注意,非第一次不要执行,会覆盖原有DB)
pip3 install smartdb # (初始化DB)
```


# PyGraphviz

[Graphviz 入门指南](https://zhuanlan.zhihu.com/p/21993254), [官方图示](https://graphviz.org/gallery/)

Graphviz 是一个开源的图可视化工具，非常适合绘制结构化的图标和网络。Graphviz 使用一种叫 DOT 的语言来表示图形。



## 介绍
- 【2020-8-4】[PyGraphviz (几何图形可视化工具) 简单入门](https://zhuanlan.zhihu.com/p/104636240)
- [Graphviz](https://graphviz.org/download/) 是一个几何图形可视化软件，能够将数据的结构信息表示为抽象图形和网络图的方式。
- PyGraphviz 主要对数据量大、可任意定制的图形上具有强大优势。
- 建议：由于 PyGraphviz 暂时无法对同源节点合并线段。在流程图、小型结构图方面，Visio 可以作为 Graphviz 的直接替代软件。

### DOT 语言

DOT语言是一种图形描述语言。能够以简单的方式描述图形，并且为人和计算机所理解。

```c++
digraph graphname{ 
    a -> {b c};
    c -> e;
    b -> d; // 有向图

    subgraph cluster_bc {
        bgcolor=red;
        b;
        c;
    }

    subgraph cluster_de {
        label="Block"
        d;
        e;
    }
```

![](https://pic4.zhimg.com/80/76fee780894d06ca266c123bc68f9bbf_720w.png)

## 安装

- 各操作系统下的安装

```shell
brew install graphviz # mac
pip install graphviz # linux
conda install graphviz # conda
```

## 使用

```python
import pygraphviz as pgv
# 创建图形
G = pgv.AGraph(directed=True, strict=False, nodesep=0, ranksep=1.2, rankdir="TB",
               splines="none", concentrate=True, bgcolor="write",
               compound=True, normalize=False, encoding='UTF-8')
# 添加节点
G.add_node(name, label=None, fontname="Times-Roman", fontsize=14,
           shape="ellipse", style="rounded", color="black", fontcolor="black",
           pos="x,y(!)", fixedsize=False, width=1, height=1)

G.add_nodes_from(names, **attr) # 批量添加点，参数同上 
# 添加边
G.add_edge(origin, target, color="black", style="solid", penwidth=1,
           label="", fontname="Times-Roman", fontsize=14, fontcolor="black",
           arrowsize=1, arrowhead="normal", arrowtail="normal", dir="forward")
# label -> str：边标签，未指定时不显示
# penwidth：线条粗细
# arrowsize：箭头大小
# arrowhead：箭头类型，可选 normal, vee
# dir：箭头方向，可选 both, forward, back, none。只有在无向图中才起作用！
G.add_nodes_from([[origin_1, target_1],
                  [origin_2, target_2],...], **attr)  # 批量添加线，参数同上
# 导出图形
G.layout()
G.draw(file_name, prog="neato")
# prog：布局算法，可选 neato, dot (推荐), twopi, circo, fdp

```

- 创建图：
    - directed -> False \| True：有向图
    - strict -> True \| False：简单图
    - nodesep：同级节点最小间距
    - ranksep：不同级节点最小间距
    - rankdir：绘图方向，可选 TB (从上到下), LR (从左到右), BT (从下到上), RL (从右到左)
    - splines：线条类型，可选 ortho (直角), polyline (折线), spline (曲线), line (线条), none (无)
    - concentrate -> True \| False：合并线条 (双向箭头)
    - bgcolor：背景颜色
    - compound -> True \| False：多子图时，不允许子图相互覆盖
    - normalize -> False \| True：以第一个节点作为顶节点
- 添加节点
    - name -> str：节点名。label 为节点标签，未指定时显示 name
    - fontname：字体名称，常用：Microsoft YaHei, SimHei, KaiTi, SimSun, FangSong, Times-Roman, Helvetica, Courier。可以使用 "times bold italic" 表示字体类型、粗细、倾斜
    - fixedsize -> Flase \| True \| "shape"`：固定大小，默认随文本长度变化。设置为 True 时，width 和 height 参数共同控制点大小。设置为 "shape" 时，将取标签文本和设置值的较大者
    - pos -> str：点的初始位置。使用 "x,y!" 时，可以强制固定点的位置。
    - style：节点线样式，使用 `color` 设置线条颜色 (style="filled" 时，设置填充颜色)
        - ![](https://pic2.zhimg.com/80/v2-bd489505b51d33d230d0f26a83a5cced_720w.png)
    - shape: 节点形状
        - ![](https://pic3.zhimg.com/80/v2-f9785df4406b61d27be1e4b73919b688_720w.jpg)


## 案例

### 因果关系图

- 效果：
![](https://pic1.zhimg.com/80/v2-ee8eea4bf4ae7307281ff7f448563c45_720w.jpg)
- 代码：

```python
import pygraphviz as pgv

G = pgv.AGraph(directed=True, strict=False, ranksep=0.2, splines="spline", concentrate=True)

# 设置节点标签
nodeA = "Police\nIntelligence"
nodeB = "Police Station"
nodeC = "Criminal Action"
nodeD = "Incidents"
nodeE = "Police Dockets"
nodeF = "Control Room\nAwareness"
nodeG = "Patroller Information"
nodeH = "Patroller Awareness"

# 添加节点
G.add_nodes_from([nodeA, nodeB, nodeC, nodeD, nodeE, nodeF, nodeG, nodeH],
                 color="#ffffff", fontname="times bold italic")

# 添加边
G.add_edges_from([[nodeA, nodeB], [nodeA, nodeF], [nodeB, nodeC], [nodeC, nodeD],
                  [nodeC, nodeG], [nodeD, nodeE], [nodeD, nodeG], [nodeE, nodeA],
                  [nodeF, nodeA], [nodeF, nodeG], [nodeF, nodeH], [nodeG, nodeF],
                  [nodeH, nodeG]], color="#7F01FF", arrowsize=0.8)

# 导出图形
G.layout()
G.draw("因果关系图.png", prog="dot")
```

### 因子相关性图

- 效果：
![](https://pic2.zhimg.com/80/v2-16cb830982e85989b8b8a53ba8e7e7e9_720w.jpg)
- 代码：

```python
import pygraphviz as pgv

G = pgv.AGraph(directed=True, rankdir="TB")

# 设置节点标签
Root = "道路交通流畅"
negative_1 = "平均延误时间"
negative_2 = "负荷度"
negative_3 = "小区位置"
negative_4 = "相对延误率"
negative_5 = "房屋密度"
negative_6 = "人口密度"
negative_7 = "总延误率"
negative_8 = "排队率"
negative_9 = "行驶时间"
positive_1 = "通行能力"
positive_2 = "公路层级"
positive_3 = "路网结构"
positive_4 = "行驶速度"
positive_5 = "路网长度"
positive_6 = "小区面积"
positive_7 = "内部道路密度"
positive_8 = "路网密度"

# 添加节点
G.add_node(Root, style="filled", shape="box3d", color="#feb64d")
for negative in [eval(_) for _ in dir() if _.startswith("negative")]:
    G.add_node(negative, style="filled", shape="ellipse", color="#CFDBF6")

for positive in [eval(_) for _ in dir() if _.startswith("positive")]:
    G.add_node(positive, style="filled", shape="ellipse", color="#B4E7B7")

# 添加边
G.add_edges_from([[Root, negative_1], [Root, negative_6], [Root, negative_8], [Root, negative_9],
                  [negative_1, negative_2], [negative_1, negative_7], [negative_2, negative_3],
                  [negative_2, negative_7], [negative_3, negative_4], [negative_8, negative_9],
                  [positive_2, negative_5], [positive_3, negative_4], [positive_4, negative_5]],
                 color="#B4DBFF", style="dashed", penwidth=1.5)

G.add_edges_from([[Root, positive_1], [Root, positive_8], [negative_5, negative_4],
                  [negative_6, positive_4], [negative_5, positive_4], [negative_9, positive_5],
                  [positive_1, positive_2], [positive_2, positive_3], [positive_6, positive_5],
                  [positive_7, positive_6], [positive_8, positive_7]],
                 color="#B4E7B7", style="dashed", penwidth=1.5)

# 导出图形
G.layout()
G.draw("因子相关性图.png", prog="dot")
```

### 神经网络图

- 效果：
![](https://pic3.zhimg.com/80/v2-c3f55cc605a0cf341faf7540a76cb53b_720w.jpg)
- 代码：

```python
import pygraphviz as pgv

G = pgv.AGraph(directed=True, rankdir="LR")

# 设置层数、每层节点数
network_structure = input("输入神经网络每层节点数，如：[10, 7, 5, 4, 2, 1]\n")
all_nodes = [[f"layer{layer_index}node{node_index}" for node_index in range(layer_nodes_num)] for
             layer_index, layer_nodes_num in enumerate(eval(network_structure))]

# 添加输入层节点
for node_index, node in enumerate(all_nodes[0]):
    G.add_node(node, label="", shape="circle", style="bold", color="#60acfc", pos=f"0,{0.6 * node_index}!")

# 添加输入层文本
G.add_node(f"Input_Layer", shape="none", label=f"Input_Layer({len(all_nodes[0])})",
           pos=f"{0},{(node_index + 1) * 0.6}!")

# 添加中间层、输出层节点
for layer_index, layer in enumerate(all_nodes[1:]):
    color = "#5bc49f" if layer_index == len(all_nodes[1:]) - 1 else "#ff7c7c"

    for node_index, node in enumerate(layer):
        x = 1.5 * (layer_index + 1)
        y = - 0.3 * (len(all_nodes[layer_index + 1]) - len(all_nodes[0])) + 0.6 * node_index
        G.add_node(node, label="", shape="circle", style="bold", color=color, pos=f"{x},{y}!")

    # 添加中间层、输出层文本
    text = f"Output_Layer({len(all_nodes[-1])})" if layer_index == len(all_nodes[1:]) - 1 else f"Layer_{layer_index + 1}({len(layer)})"
    G.add_node(f"Layer_{layer_index + 1})", shape="none", label=text,
               pos=f"{x},{y + 0.4}!")

# 添加线
for layer_index in range(all_nodes.__len__() - 1):
    for start in all_nodes[layer_index]:
        for end in all_nodes[layer_index + 1]:
            G.add_edge(start, end)

# 导出图形
G.layout()
G.draw("神经网络.png")

# 运行代码，输入 [5, 10, 15, 15, 15, 10, 5, 1]
```

### 有限状态机FSM的可视化

- 有限状态机（Finite-state machine, FSM），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。FSM是一种算法思想，简单而言，有限状态机由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数组成。
- [Transitions](https://github.com/pytransitions/transitions)
- [Python的Transitions库实现有限状态机(FSM)](https://www.jianshu.com/p/decf86e0e420)

```python
from transitions.extensions import GraphMachine

states = ['first', 'second']
transitions = [
    ['any_trigger', 'first', 'first'],
    ['anything', '*', 'second'],
]

machine = GraphMachine(states=states, transitions=transitions, initial='first',
                       auto_transitions=False, show_conditions=True)

machine.get_graph().draw('fsm.png', prog='dot')
from IPython.display import Image
Image('fsm.png')
```

- 结果
![](https://upload-images.jianshu.io/upload_images/618241-70acdf59c5f312c8.png)

# turtle工具

[python中的画图神器——turtle模块](https://zhuanlan.zhihu.com/p/106388608)

turtle库的基础命令介绍

## 画布

画布cancas是绘图区域，可以设置它的大小和初始位置

```python
turtle.screensize(1000,600,'red')    # 大小的设置
turtle.setup(width=0.5,height=0.75)  # 初始位置
```

## 画笔

### （1）画笔运动的命令

```python
turtle.forward(a)   # 向当前画笔方向移动a像素长度
turtle.backward(a)  # 向当前画笔相反方向移动a像素长度
turtle.right(a)     # 顺时针移动
aturtle.left(a)     # 逆时针移动
aturtle.pendown()   # 移动时绘制图形
turtle.goto(x,y)    # 将画笔移动到坐标为x,y的位置
turtle.penup()      # 移动时不绘制图形，提起笔
turtle.speed(a)     # 画笔绘制的速度范围
turtle.circle()     # 画图，半径为正，表示圆心在画笔的左边画圈
```

### （2）画笔控制命令

```python
turtle.pensize(width)   # 绘制图形的宽度
turtle.pencolor()       # 画笔的颜色
turtle.fillcolor(a)     # 绘制图形的填充颜色
turtle.color(a1,a2)     # 同时设置pencolor=a1,fillcolor=a2
turtle.filling()        # 返回当前是否在填充状态
turtle.begin_fill()     # 准备开始填充图形
turtle.end_fill()       # 填充完成
turtle.hideturtle()     # 隐藏箭头显示
turtle.showturtle()     # 显示箭头
```

### （3）全局控制命令

```python
turtle.clear()   # 清空turtle窗口,但是turtle的位置和状态不会改变
turtle.reset()   # 清空窗口，重置turtle状态为起始位置
turtle.undo()    # 撤销上一个turtle动作
```

## 实战

[原文](https://zhuanlan.zhihu.com/p/106388608)涉及案例：樱花、玫瑰花、皮卡丘、星空、小黄人、单身狗等

### 爱心

![img](https://pic1.zhimg.com/80/v2-1fc08ade2e2384dd1e2634f4a696bb9c_1440w.jpg)

```python
from turtle import *

color('red', 'pink')  # 画笔色red，背景色pink
begin_fill()
left(135)  # 左转135°
fd(100)  # 前进100像素
right(180)  # 画笔掉头

circle(30, -180)

backward(35)  # 由于此时画笔方向约为绝对方向的135°，需倒退画线
right(90)
forward(35)
circle(-30, 180)
fd(100)
end_fill()
hideturtle()
done()
```




# 结束


