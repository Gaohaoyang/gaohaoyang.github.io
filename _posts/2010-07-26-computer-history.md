---
layout: post
title:  "计算机发展史-Computer History"
date:   2010-07-26 23:42:00
categories: 计算机基础
tags: 高德纳 乔姆斯基 图灵 冯·诺依曼 陈皓 少儿编程 网络 体系结构 CPU arm x86 OSI
excerpt: 计算机发展历史，编程语言诞生过程，及几位关键人物
mathjax: true
---

* content
{:toc}

# 总结

- 【2021-6-16】[你管这玩意儿叫CPU？](https://www.toutiao.com/i6974241663241683463/). 过去200年人类最重要的发明是什么？蒸汽机？电灯？火箭？这些可能都不是，最重要的是晶体管,无论程序员编写的程序多么复杂，软件承载的功能最终都是通过这个小东西简单的开闭完成的. 组成与或非门。
- 【2021-3-31】[图灵奖今日出炉](https://mp.weixin.qq.com/s/Q6kbBomC85xbmKS2SLllfA)，“龙书” 作者、编程语言大佬 Alfred Aho 和 Jeffrey Ullman 获奖
- 【2020-10-29】源自linux之父的名言：**talk is cheap，show me the code**，汉化版：**北沙滩**（别瞎谈），**亮马桥**（亮码瞧）
- 计算机网络里的 **OSI七层模型** 或 **TCP/IP五层模型**，即应用层（应用层、表示层、会话层）、传输层、网络层、数据链路层、物理层
![](https://pic4.zhimg.com/50/v2-6531ff0d8cbf967211297ef7c7813ab1_hd.jpg)

- [OSI七层模型](https://www.toutiao.com/w/a1701287080764423/)

![](https://p5.toutiaoimg.com/img/tos-cn-i-0022/d2916c97afc94b9daa01bdaca34759a0~tplv-obj:1575:2227.image?from=post)

# [计算机编程简史](https://coolshell.cn/articles/2724.html)

- 一张经典的图揭示计算机发展历史
- 可以看到，其中很大一部分人都和Unix有着不解之缘
   - 参见《[Unix传奇上篇](https://coolshell.cn/articles/2322.html)，[Unix传奇下篇](https://coolshell.cn/articles/2324.html)》
 
*   [英文原版](http://www.smashingmagazine.com/2010/06/06/designing-the-world-of-programming-infographic/)
*   [中文翻译版](http://www.mazingtech.com/cn/list.aspx/News/1/%E5%9B%BE%E8%AF%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8F%B2)

---

[![](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04.eng_-409x1024.jpg "计算机编程简史图（英文版） ")](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04.eng_.jpg)
 
计算机编程简史图（英文版）
 
[![](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04_cn-409x1024.jpg "计算机编程简史图（中文版） ")](https://coolshell.cn/wp-content/uploads/2010/07/aboutprogramming04_cn.jpg)
 
计算机编程简史图（中文版）

## 计算机之父
- “计算机之父”这种笼统的称谓没有明确的结果。你可以认为是图灵，也可以认为是冯·诺依曼，你认为是谁就是谁。
- 非要叫的话可以是：
   - `巴贝奇`Charles Babbage——**通用计算机**之父
      - 巴贝奇在1834年所构思的分析机（通用计算机），就已有了计算机的五个部分：处理器、控制器、存储器、输入与输出装置，而不是到了冯·诺依曼才提出的。
      - 生活在机械时代，却构思出了完整的计算机结构，领先世界一百年。
      - [机械美学：差分机的运作](https://v.qq.com/x/page/i0164fo4om1.html)
      - <iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=d0319t31fw9" allowFullScreen="true" height="600" width="100%"></iframe>
   - `图灵`Alan Turing——**计算机科学**之父
      - 图灵在现在毫无疑问是名气最大的，有套书以他命名，还有个公司用他咬过的苹果做logo。
      - 图灵也是个天才，他的工作非常有开创性，系统建构了计算机科学的基础，提出了图灵机、图灵测试，所以被称为“计算机科学之父”。
   - `约翰·阿坦那索夫`John Vincent Atanasoff——**电子计算机**之父
      - 阿坦纳索夫和克利福德·贝瑞在1939年制造了`ABC机`。
      - 在电子时代，作为第一台电子计算机的发明者，拔得了头筹，也够资格被称为“电子计算机之父”了。
      - 那时也已经开始使用二进制了，所以二进制也不是冯·诺依曼首创的。
   - `冯·诺依曼`John von Neumann——**现代计算机**之父
      - 在科学界名声很响，有许多开创性的工作，包括数学、量子力学、计算机和经济学领域。
      - 他对二战的贡献很大，不仅参与原子弹研制，还对ENIAC作了关键改进。
      - 另外他还最终完善了计算机的模型，提出冯诺依曼机，奠定了我们现代所使用的计算机的基础。所以把冯诺依曼称为“现代计算机之父”是实至名归的。

- 参考作者：[滑稽现实主义](https://www.zhihu.com/question/27883465/answer/93161520)


## 图灵

- ![](https://pic2.zhimg.com/80/v2-acdf678e24dba6143bc5cfeea626afb0_720w.jpg)

### 成长经历

- 艾伦·麦席森·图灵（英语：Alan Mathison Turing，1912年6月23日—1954年6月7日），英国数学家、逻辑学家，被称为计算机科学之父，人工智能之父。
- 1931年图灵进入剑桥大学国王学院，毕业后到美国普林斯顿大学攻读博士学位，第二次世界大战爆发后回到剑桥，后曾协助军方破解德国的著名密码系统Enigma，帮助盟军取得了二战的胜利。
- 1952年，英国政府对图灵的同性恋取向定罪，随后图灵接受化学阉割（雌激素注射）。
- 1954年6月7日，图灵吃下含有氰化物的苹果中毒身亡，享年41岁。
- 2013年12月24日，在英国司法大臣克里斯·格雷灵的要求下，英国女王伊丽莎白二世向图灵颁发了皇家赦免。
- 图灵对于人工智能的发展有诸多贡献，提出了一种用于判定机器是否具有智能的试验方法，即图灵试验，至今，每年都有试验的比赛。此外，图灵提出的著名的图灵机模型为现代计算机的逻辑工作方式奠定了基础。

1912年6月23日，图灵出生于英国帕丁顿一个没落的贵族家庭，由于父母常年在印度工作，他和年长4岁的哥哥一起被寄养在一对军人夫妇的家中。图灵的童年十分平凡，和普通男孩一样，经历过**调皮捣蛋**和**孤僻寡言**的的阶段，他天性聪敏却有着严重**偏科**的倾向，许多教过他的老师对他的评价并不高。

10岁那年，图灵接触到一本改变了他一生的童书——《**儿童必读的自然奇迹**》，这本科普读物打开了一扇新世界的大门，图灵发现门的那边堆满了一种对他来说最有吸引力的知识——**科学**。他开始**疯狂**地寻找和自学有关科学的一切知识，并用日用品做一些简单的化学实验。他很快意识到手头的科普读物过于浅显，妨碍了他了解事物背后更深层的原理。他甚至写信给父母讨要真正的科学书籍，而不是儿童百科。他写到：“《儿童必读的自然奇迹》中说，二氧化碳在血液里变成苏打，又在肺里变回二氧化碳。如果可以，请把苏打的化学名称，最好是化学式寄给我，好让我看看这个过程到底是怎么进行的。” 13岁时，他已经对酒精等有机物的分子式和结构式了如指掌。

1926年，聪明好学而又对科学知识近乎偏执的图灵考入了舍尔伯尼中学。开学当天正赶上英国大罢工，公共交通瘫痪，图灵竟用两天时间靠自行车征服了到学校的60英里（近100公里）路程。这不是一次冲动之举，而是精心策划之下的行动，当地报纸还专门刊载了这一令人吃惊的事迹。

图灵很有才，也很有**执行力**，却在与人沟通上遇到了大麻烦。知子莫若母，图灵的母亲在为他寻找合适的中学时就一度担心他没法适应公学生活，成长为高智商、低情商的怪人。在讲究教条与制度而不重视理性和科学的舍尔伯尼，图灵显得格格不入，被多数同学孤立和欺负，连老师也经常拿他的小习惯开涮，这对一个心智尚未成熟的男孩来说非常可怕。他们的校长倒看得十分透彻，曾警告图灵的父母：“我希望他不要两头都落空。如果他要留在公学，就必须以好好接受我们的教育为目标；如果他只是想做科学家，那么呆在公学就是浪费时间。”

舍尔伯尼是当时英国社会的一个缩影，中学的经历也预示着图灵不被理解的一生。

1931～1934年，成年后的图灵在剑桥大学国王学院攻读**数学**专业。尽管这里的制度依旧古板，像个放大版的舍尔伯尼，图灵依旧孤僻，但接触到了世界顶级的数学家和一流的学术专著，他可以更专注于自己喜欢的领域，并包揽了许多数学方面的奖项。毕业后，图灵以优异的成绩成为国王学院研究员。他在希尔伯特的问题上花费了整整一年的时间，最终在1936年的《**伦敦数学协会会刊**》上发表了那篇改变世界的论文——《**论可计算数及其在判定问题中的应用**》，提出了使其成为“计算机科学之父”的图灵机。

论文正式发表之前，图灵只身前往美国普林斯顿，在那里找到了领先一步发表成果的邱奇，并师从他继续深造。1937年，图灵嗅到了纳粹德国引战的可能，开始把业余时间花在密码学的研究上。1938年，图灵在取得博士学位后返回了正在紧张备战的英国，不多久，他便参与到政府的密码破译[3]项目中，和全国各地顶尖的数学家们一起，在白金汉郡的布莱切利公馆（Bletchley Park）中深居简出，左右世界战争的格局。

二战时期，各国已经使用无线电进行作战指挥，由于信号可以轻易被敌国接收，需要对无线电内容进行加密，比如将“ABCD”改成“BCDE”发出去，当然军用的加密方式不会如此简单。当时的德国使用一种叫谜机（Enigma machine）的加密机器，按下某个字母的按键，其加密后对应的字母小灯就会亮起。内部的转轮和接插线板将这种对应关系随意打乱，每按一次按键，转轮就会转动一次，组合成新的对应关系，比如第一次按下A，D灯亮起，再按一次A，亮起的可能是Z灯，毫无规律可循。更棘手的是，德军几乎每天都会变更其中的接线。
- <img src="https://pic4.zhimg.com/80/v2-b36ef92aabab27e6ce53e2d0c66e770f_720w.jpg" width="40%" >

解密的方式是**穷举**，即遍历所有可能的对应关系，直到找出有意义的关键词，而这恰恰是机器最擅长的事。英国的同盟国波兰在战前就成功研制了破解谜机的**炸弹机**（bomba），可惜德国在1938年年底将谜机上的转轮从3个增加到了5个，解密的复杂度呈爆炸式增长，针对3转轮谜机设计的炸弹机还未在二战发挥价值就已经宣告报废。解决这个难题的关键人物正是**图灵**，新建的炸弹机（bombe）成功破解了5转轮谜机。其难度之大，大到英国首次利用破解的信息破坏德军行动时，德国的密码专家首先排除了谜机被破解的可能性。
- <img src="https://pic4.zhimg.com/80/v2-4ba1b7d04c066452bfe03492a0e4803f_720w.jpg" width="40%" >

随后，对密码学有着深刻认识的图灵还探索出一种高效的解密算法，人称图灵方法（Turingery），该算法成为布莱切利破解德国密码的核心理论。

布莱切利的工作是图灵在短暂的一生中，为人类所做的第二项伟大贡献。他的成果使战争至少提前2年结束，挽救了至少1400万人的生命。前英国首相温斯顿·丘吉尔曾表示，二战的胜利最该感谢的人就是图灵。

战后，图灵进入国家物理研究所，并设计了属于最早一批电子计算机之一自动计算机ACE（Automatic Computing Engine），首次实现了他心目中的通用图灵机。1950年3月10日，ACE的简化版Pilot ACE开始运行，完整的ACE直到图灵去世之后才建成。
- <img src="https://pic2.zhimg.com/80/v2-1b65d32fd247bf60a1d6417f7158e4a1_720w.jpg" width="70%" >

1948年，图灵成为曼彻斯特大学数学系讲师，并于次年担任学校计算机实验室的副主任，负责计算机软件的研究。他还成为计算机企业的顾问，帮助其研发商用电子计算机。1951年，英国皇家学会将图灵吸纳为会员。

这些年间，图灵的主要智慧仍留给了数学和计算机的理论研究。1950年，第二篇影响世界的论文《计算机与智能》问世，在那个电子计算机才刚刚起步的年代，高瞻远瞩的图灵用一个问题就叩开了人工智能的大门：“机器会思考吗？”文中提出了著名的`图灵测试`（Turing test）：
- 让一台机器躲在挡板后回答测试人员的提问，看测试人员能否判断自己面对的是机器还是真人。
- 能否通过图灵测试，是衡量机器智能程度的重要指标。
- 这位“人工智能之父”过于乐观地预言：到2000年，计算机应该能“骗过”30%的测试人员。

图灵机、炸弹机、人工智能……图灵献给世界太多伟大的作品，却没能在生前得到应有的名誉乃至起码的认可。人们始终觉得他是个难以亲近的怪人，对其二战时期涉密的功绩更是一无所知。

- 1952年，他因同性恋的罪名被起诉，在坐牢和化学阉割之间，他无奈选择了后者，旁人的偏见和药物的副作用使他承受着精神和肉体的双重痛苦。
- 1954年6月7日晚上，他躺在家里因氰化物中毒离开了人世，床头放着一个咬过的苹果，还有16天就是他42岁的生日。尸检的结果认定图灵是通过毒苹果自杀的，却没有对这个苹果做氢化物检测，他的母亲和哥哥却坚持认为这是一场化学实验导致的意外，而真相只有图灵自知。
- 2009年，超过3万人在线请愿为图灵平反，英国首相戈登·布朗代表政府公开道歉。2013年，英国女王伊丽莎白二世正式颁发皇家赦免，图灵终于得到了迟来的公道。
- 1966年，美国计算机协会ACM（Association for Computing Machinery）设立计算机领域的最高奖项，命名为图灵奖。图灵奖素有“计算机界的诺贝尔奖”之称，图灵的名字当之无愧。
- 2019年，英国的中央银行——英格兰银行宣布，图灵的肖像将出现在新版的50英镑纸币上，以此纪念这位改变了国家乃至整个世界命运的伟人。

[图灵机：计算机世界的理论基石](https://zhuanlan.zhihu.com/p/135251031)

### 图灵奖

- 待补充


### 图灵机


### 图灵机历史

[图灵机：计算机世界的理论基石](https://zhuanlan.zhihu.com/p/135251031)

- 公元前4世纪，由哲学家欧布里德（Eubulides）提出的著名的**说谎者悖论**。
  - 古老而经典的逻辑游戏：如果一个人说“我正在说谎”，那么他到底在不在说谎呢？
    - 如果他不在说谎，那么“我正在说谎”这句话就是真的；
    - 如果他  在说谎，那么“我正在说谎”这句话就是假的。
  - 无论从哪个方向推演，得到的都是**自相矛盾**的结论，我们无从判定他在不在说谎。
- 类似的，还有伯特兰·罗素（Bertrand Russell）在1901年提出的**罗素悖论**，它的通俗化版本是流传更广的理发师悖论：
  - 如果一位理发师只给不为自己理发的人理发，那他给不给自己理发呢？
  - 罗素悖论直接动摇了整个数学大厦的根基——`集合论`。为使命题合理，当那位理发师圈定服务对象的范围时，必须把自己排除在外。这也就意味着，没有包罗万象的集合——至少它不能轻易包含自己。
- 这些悖论都源自“罪恶”的自指 —— <font color='red'>当一套理论开始描述自身，就难免要出现悖论。</font>
  - 即使再不情愿，人们也不得不承认数学是不完美的，至少它没有自圆其说的能力。
- 尽管如此，仍有数学家想在限定的范围内负隅顽抗，他们找到一个完备的系统，寻求能够判定命题真假的通用算法。这就是德国数学家大卫·希尔伯特（David Hilbert）和威廉·阿克曼（Wilhelm Ackermann）在1928年提出的**判定问题**（Entscheidungsproblem/decision problem）。
- 只可惜没过几年，这种可能性也被否定了。
- 1936年，两位年轻的数学家分别用不同的方法给出了判定问题的解答。
  - 一位是来自美国的阿隆佐·邱奇（Alonzo Church），他引入了一种叫**λ演算**的方法，并最终证明没有任何通用算法可以判定任意两个λ表达式是否相等；
  - 另一位就是来自英国的艾伦·图灵（Alan Turing），和枯燥的数学推理不同，他使用了一种更有趣、更形象的模型，邱奇给了它一个响亮的名字——`图灵机`（Turing machine）。

#### 图灵机介绍

图灵机是数学家阿兰·图灵1936年提出来的虚拟的机器，尽管这个机器很简单，但它可以模拟计算机的任何算法，无论这个算法有多复杂。
- ![](https://pic2.zhimg.com/80/v2-94ce773233e7ce82a440c59239f384d9_720w.jpg)
- 假设有一个无穷的纸带，纸带就像一个存储器一样。纸带上面的每个格子是空白的，但是可以读写数据，在这个例子里，机器只能写0，1，或者什么也不写。这个机器就是包含3个信号的图灵机。
- 机器有一个探头，这个头可以移动到每一个空格上，用这个头，机器可以有3个基本操作。
  - 1、 读空格的数据
  - 2、 编辑数据，可以是写一个新的数据，可以是擦除数据
  - 3、 移动纸带向左或者向右，这样机器可以读或者编辑旁边的格子
- 参考：Computer laboratory of university of Cambridge。剑桥大学计算机系：[What is a Turing machine?](https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html)


图灵机的基本组成如下：
- 有一条「纸带」，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；
- 有一个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写入到纸带的格子；
- 读写头上有一些部件，比如存储单元、控制单元以及运算单元：
  - 1、存储单元用于存放数据；
  - 2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等；
  - 3、运算单元用于执行运算指令；

作者：[小林coding](https://www.zhihu.com/question/348237008/answer/1956489945)

图灵机的样子：
- ![](https://pic2.zhimg.com/80/v2-cd2fdeef6ca619507aea9fb06408e91b_720w.jpg)


#### 图灵机工作原理

图灵的基本思想是用机器来**模拟**人们用纸笔进行数学运算的过程，而且还定义了计算机由哪些部分组成，程序又是如何执行的。

图灵机是图灵受打字机的启发而假想出来的一种抽象机器，其处理对象是一条无限长的一维纸带。纸带被划分为一个个大小相等的小方格，每个小方格可以存放一个符号（可以是数字、字母或其他符号）。有个贴近纸带的读写头，可以对单个小方格进行读取、擦除和打印操作。为了让读写头能访问到纸带上的所有小方格，可以
- （1）固定纸带，让读写头沿着纸带左右移动，每次移动一格
- （2）固定读写头，让纸带左右移动

后一种方式类似当时穿孔带以及后来磁带和磁盘的做法，但在纯理论讨论时为了方便说明，我们通常选用前一种方式。
- ![](https://pic4.zhimg.com/80/v2-a0e8c204190e73aa563aee8231e74ccb_720w.jpg)

读写头该如何移动，移动之前或移动之后又该作何操作呢？
- 这取决于机器当前的状态，以及读写头当前所指小方格中的内容，机器中有着一张应对各种情况的**策略表**。
- 构造一台简单的图灵机，实现对纸带上所有3位二进制数的+1操作（超过3位的进位将被丢弃），相邻两个二进制数之间通过一个空的小方格隔开，形如下图所示，读写头从最右侧二进制数的最低位开始扫描，遇到连续2个空方格时认为已处理完所有数，机器停机。
- ![](https://pic2.zhimg.com/80/v2-e6046f3625fe5b55d4cd046ed086291d_720w.jpg)
- 策略表：E表示擦除、P表示打印、L表示左移。
  - <img src="https://pic1.zhimg.com/80/v2-b236f764ee2b1fee60b76400d3b01a20_720w.jpg" width="40%" >
  - 该图灵机有3种工作状态：+1、左移和判断
    - S1 是+1状态，也是机器的初始状态。如果读写头遇到的是0，则直接将0改为1即完成了+1任务，左移一格后进入状态 S2 ；如果遇到的是1，则将1改为0，由于需要进位，即对下一位+1，左移一格后仍留在状态 S1；如果遇到的是一个空方格，即使当前需要进位，也不做处理（将进位丢弃），左移一格后进入状态 S3 。
    - S2 是左移状态，此时已实现当前二进制数的+1，需要将读写头移到下一个数的最低位。如果遇到0或1，说明读写头还在当前二进制数上，继续左移；如果遇到空方格，后面等着它的可能是下一个二进制数，也可能是永无止境的空方格，左移一格之后进入状态 S3 。
    - S3 是判断状态，根据情况判断是否还有二进制数要处理。如果读写头遇到的是0或1，说明当前位置是一个新的二进数的最低位，直接交给 S1 处理；如果遇到的仍是空方格，说明后续不再有数据，停机。
  - <img src="https://pic4.zhimg.com/80/v2-04ec7765ec434701710f52ec43b30e63_720w.jpg" width="70%" >
- 如法炮制，可以设计出具有各种功能的图灵机，而策略表的制定则类似于**编程**。图灵想到，如果把策略表中的信息以统一的格式写成符号串（比如上表可以表达成S1/0/EP1L/S2 S1/1/EP0L/S1 S1//L/S3 ……），然后放在纸带的头部，再设计一台能在运行伊始时从纸带上读取这些策略的图灵机，那么针对不同的任务，就不需要设计不同的图灵机，而只需改变纸带上的策略即可。这种能靠纸带定制策略的图灵机，称为`通用图灵机`UTM（universal Turing machine）。
- 不单是策略表，其实用于描述图灵机的所有信息（包括所使用的符号、初始状态等）都可以表达成纸带上的符号串。这就意味着，一台图灵机可以成为另一台图灵机的输入。

判定问题的解答
- 试想一下，有些情况下，一台图灵机如果长时间没有输出结果，那么很可能陷入了**死循环**或永无止境的计算中。这是不愿看到的，因为机器可能运行1分钟后停机，也可能运行10天半个月甚至几十年才停机，亦或者永远也不会停机，这个很难靠人为判断。假设构建出一台图灵机H，接收其他图灵机及其输入信息作为输入，并能够判定其是否会停机，就解决了上面的烦恼——构建这样的机器难度虽大，但理论上是可行的。
这就是著名的**停机问题**（halting problem）。

H所处理的，本质上正是一种判定问题：某台图灵机在某输入上是否会停机。只要找到一台H判定不了的机器，希尔伯特的美梦就破灭了。

令H表现如下图所示，如果其判定对象会停机则输出1，反之输出0。
- <img src="https://pic1.zhimg.com/80/v2-8383f0d2038dd8e8b52eaf8f92cacc8c_720w.jpg" width="40%" >

再构建一台图灵机G，其运行流程如下图所示。如果H输出1，说明G会停机，但事实上它将陷入循环；如果H输出0，说明G不会停机，但事实上它将停机。
- <img src="https://pic4.zhimg.com/80/v2-8f244b5457adf4c0a05927f99fb1a337_720w.jpg" width="40%" >
悖论已经出现，H无法对G的停机问题进行判定。又一次归因于尴尬的自指：当一个系统强大到一定程度时，终究会遇到无法处理自己的窘境。

因此，**不存在一台图灵机，可以判定任意图灵机是否会停机**。图灵机不是万能的，判定问题的答案也是否定的。而这个看似有点耍赖的证明方式，有着图灵长达36页的数学论证支撑。


#### 图灵机意义

图灵的工作不仅回答了**希尔伯特**的问题，更参透了数学和计算机的本质关系——<font color='blue'>计算机是为解决数学问题而诞生的，却又基于数学，因而数学自身的极限也便框定了计算机的能力范围。</font>

图灵虽然证明了**没有任何机器可以解决所有数学问题**，却也证明了**机器可以完成所有人类能完成的计算工作**，从如今的应用看来，后一个结论的意义重大得多。

从图灵开始，计算机有了真正坚实的理论基础，更多人开始投身计算机的理论研究，而不仅是尝试构建一台机器。从如今的应用来看，图灵机之于计算机领域的价值远高于数学领域，毕竟判定问题还有λ演算和许多其他解答，但计算机的原始公式，只有图灵机这一个。

如今的**所有通用计算机都是图灵机的一种实现**，两者的能力是等价的。
- 当一个计算系统可以模拟任意图灵机（或者说通用图灵机）时，我们称其是**图灵完备**的（Turing complete）；
- 当一个图灵完备的系统可以被图灵机模拟时，我们称其是**图灵等效**的（Turing equivalent）。
- **图灵完备**和**图灵等效**成为衡量计算机和编程语言能力的基础指标，如今几乎所有的编程语言也都是图灵完备的，这意味着它们可以相互取代，一款语言能写出的程序用另一款也照样可以实现。


## 冯诺依曼

- ![](https://pic2.zhimg.com/80/v2-e4d433440561afc5f86bb3e14abd500f_720w.jpg)
- `冯·诺依曼`体系计算机又称存储程序计算，主要由以下几部分组成：
   - CPU（Central Processing Unit）：由控制器、运算器以及寄存器组成
   - 存储器（Memory）:即我们常说的内存
   - I/O设备：输入输出设备
- ![](https://pic2.zhimg.com/80/v2-7c443e162c8c42a605c63dedb96dda1e_720w.jpg)
- 主要特点
   - 程序存储执行
      - 计算机是靠诸多晶体管控制电路而运行，早期的计算机是靠手动控制电路执行，这种设计缺点在于，程序是一次性执行，即没办法存储起来反复执行；
      - 冯·诺依曼体系计算机，则提出了程序是可存储执行，即人们把要执行的程序存储在一个地方，然后在运行的时候让CPU去固定的地方去取，这样做的好处是程序可以存储起来多次运行，且修改程序不需要手动调整电路；
   - 二进制逻辑
      - 十进制逻辑的计数有利于人类阅读，但不利于电路设计，在电路中，状态一般有两种开启或者关闭，二进制逻辑的设计简化了计算机内部电路的设计
- 【2021-3-14】“冯·诺伊曼架构”，简单说就是要有 CPU，内存，显示器和键盘。用键盘给 CPU 下命令，CPU 和内存一起合作，算出结果输出给显示器就可以。
  - 不过 CPU 非常傻，只认识 0 和 1 两个数字。所以如果想算一道算数题，得告诉机器一串 24 位的数字 1000 0011 1100 0000 0000 0001（机器码，ADD %EAX, 1）, 他才能听懂。无论用 Python、C++ 还是别的编程语言，最终都会转换成这 24 个数字。
  - ![](https://p6-tt.byteimg.com/origin/pgc-image/a1515800335f48ae96ff652f84255185?from=pc)

- ![](https://pic1.zhimg.com/80/v2-92fdb4030ccc4cc1aacda3dd200291c9_720w.jpg?source=1940ef5c)

## 高德纳
- [Donald Knuth](https://www-cs-faculty.stanford.edu/~knuth/)，高德纳，《[计算机程序与设计](http://www-cs-faculty.stanford.edu/~uno/taocp.html)》作者，计算科学之父
   - 计算机科学技术中两个最基本的概念：“`算法`”(Algorithm)和“`数据结构`”(Data Structure)就是高德纳于 29 岁时提出来的
   - 艺术是人类智慧的最高形式
   - 高德纳是他的中文名，是 1977 年他访问中国之前所取的，命名者是姚储枫(姚期智的夫人，夫妇都是计算机科学家)。
   - [计算机鼻祖-Donald Knuth（高德纳） 的传奇](https://blog.csdn.net/gatieme/article/details/25613645)

![](http://5b0988e595225.cdn.sohucs.com/images/20180116/caa893f622634d1a8cf8e52f27a99bce.jpeg)

# 计算体系结构

## 计算机指令集

CPU的指令及构架，X86架构，Arm架构，微架构，还有手机处理器上的76、A55这些都是什么东西，它们之间到底是什么样的关系

参考：
- [Arm vs x86: Instruction sets, architecture, and all key differences explained](https://www.androidauthority.com/arm-vs-x86-key-differences-explained-568718/), [中文版](https://www.google.ae/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjf1tyj5ZzPAhWGWRQKHUoTDJAQFggaMAA&url=http%3A%2F%2Fwww.vaikan.com%2Farm-vs-x86-key-differences-explained%2F&usg=AFQjCNF1yxB0Q64ud33gwpMFqGz4gywKgg&bvm=bv.133178914,d.d24)
- [一文看懂arm架构和x86架构有什么区别](https://blog.csdn.net/bleauchat/article/details/90114342)

计算机的体系结构从指令集的复杂度上可以分两类
- 一类是复杂指令集CISC，主要是X86架构。
- 另一类是精简指令集RISC，这个比较多，主要是ARM、MIPS、PowerPC等。

目前x86和arm的能耗比已经差不多了，关键还是生态。现在大家都用arm指令集，自然软件，操作系统都对arm有各种优化，现在突然来个x86，小的应用厂商已经建立起arm的开发体系和人才队伍了，要真让他们在支持x86，那真是太难为他们了。大厂，比如苹果三星，都自己做处理器，也是arm指令集的，更加没有必要用x86了。应该说x86在移动端已经很难挤进去了

从CPU发明到现在，有非常多种架构，从我们熟悉的X86，ARM，到不太熟悉的MIPS，IA64，它们之间的差距都非常大。但是从最基本的逻辑角度可以分两大类，即所谓的“**复杂指令集** CISC ”与“**精简指令集** RISC”系统。 Intel和ARM处理器的第一个区别是，前者使用复杂指令集（CISC)，而后者使用精简指令集（RISC）。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。

作者：[波心荡](https://www.zhihu.com/question/20148756/answer/103220283)

## 如何查看linux体系结构

[如何查看linux系统的体系结构](https://blog.csdn.net/lixuande19871015/article/details/90485929)

命令：

```shell
# (1) aarch64就是ARM架构
uname -a
# Linux tegra-ubuntu 4.4.38-tegra #1 SMP PREEMPT Fri Jul 28 09:55:22 PDT 2017 aarch64 aarch64 aarch64 GNU/Linux
uname -m
# 。。。。
file /bin/bash
# 含ARM
# /bin/bash: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.7.0, BuildID[sha1]=64c27467ad7a6c507c8f79464fea872fed5dd044, stripped
arch
# aarch64
cat /proc/cpuinfo # 查看cpu信息

# (2) x86架构
uname -a
# Linux ubuntu 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
uname -m # 返回 x86_64

file /bin/bash
# /bin/bash: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=04eca96c5bf3e9a300952a29ef3218f00487d37b, stripped
arch
# x86_64 或i386

# (3) MIPS架构
uname -a
# Linux DrogooBox 3.3.8 #33 Tue Mar 22 15:02:01 CST 2016 mips GNU/Linux

```


## ARM —— 精简指令集

### 什么是ARM

ARM架构过去称作进阶精简指令集机器（AdvancedRISCMachine，更早称作：AcornRISCMachine），是一个32位精简指令集（RISC）处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性 .

在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.

### ARM架构

ARM构架图
- ![](http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg)

它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据/地址寄存器组成.
- 1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。
- 2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移/右移n位、环移n位和算术右移n位等都可以一次完成。
- 3、高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1/3）。
- 4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。
- 5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。
- 6、寄存器

## x86 —— 复杂指令集

![](http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg)

这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:
- 1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。
- 2：北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。
- 3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I/O总线较多，离处理器远一点有利于布线。
- 4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。
- 5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。
- 6：显示接口
- 7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。
- 8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。
- 9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。
- 10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。
- 11：总线

## x86 vs ARM

ARM采用了RISC，x86采用了CISC指令集，二者的差异表现在了能耗和速度上。RISC的能耗较低，但执行速度慢；x86的速度高能耗大。

从性能、扩展能力、操作系统的兼容性、软件开发的方便性及可使用工具的多样性及功耗这五个方面详细的对比了arm架构和x86架构的区别

### 一、性能 

X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。

但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.

### 二、扩展能力

X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.

ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则.

### 三、操作系统的兼容性

X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。

ARM系统几乎都采用Linux的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的Android系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.

### 四、软件开发的方便性及可使用工具的多样性

X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。

Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。

对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。

从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：功耗.

### 五、功耗 

X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.


# 编程语言

## 计算机课程

计算机速成课 [Crash Course Computer Science](https://thecrashcourse.com/courses/computerscience)，Carrie Anne Philbin在本课程以入门级大学材料和AP计算机科学原理指南为基础。 笔记：[CPU中的程序是怎么运行起来的](https://blog.csdn.net/wgp2hpp/article/details/110790031)
1. 概述计算机的历史以及为我们提供现代计算机的设计决策
2. 描述编程和软件的基本要素
3. 确定计算机硬件的基本组件及其作用
4. 描述如何使用计算机以及计算机如何随着时间演变
5. 了解计算机的普及程度以及

[Youtube地址](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo)

<iframe src="//player.bilibili.com/player.html?aid=457294840&bvid=BV145411j7aH&cid=242822115&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"  height="600" width="100%"> </iframe>



## 语言

- 各种编程语言之间确实有高低级之分，但不是培训班 Tony 老师告诉的高低级。 
  - ADD %EAX, 1 叫做**汇编**语言，是低级语言，而 Python 和 C++ 则同属于**高级**语言范畴。
  - C++ 是基于 C 语言“改进”而来，Python 则是由 C 语言编写的。
- 那么 Python 和 C++ 谁更高级呢？
  - 在数据科学和人工智能领域，Python 是当之无愧的王者
  - 但在高频交易、网络游戏领域，C++ 可以说是目前的业界标准。
  - 对于少儿编程领域来说，Python 在简单易入门方面几乎没有对手。
- Python 有多简单呢？写一个同样功能的网站，用汇编语言，C++ 与 Python 的工作量对比大约是 1000000:3:1
- Python 和 C++ 的真正区别是**编译型**语言与**解释型**语言的区别，简单来说就是 C++ 是直接变成 0101 让 CPU 运行的，而 Python 则需要随身带个翻译，这就导致 Python 在运行时比 C++ 慢 10 - 100 倍左右。不过不用担心，现在的 CPU 已经快到让你感觉不到任何区别。
- 为什么 Tony 老师说 C++ 比 Python 高级呢？当然是因为学同样的东西，他能收 3 倍的课时费，贵的就高级，没毛病。
  - Tony 老师也许会反驳说 Python 只是玩具语言，大一点的孩子都不用。
  - 我们可以看一下 2016 ～ 2020 编程语言流行度排行榜:
    - ![](https://p3-tt.byteimg.com/origin/pgc-image/b967e918b1824010b6c94ba760438f89?from=pc)
- 参考
  - 【2021-3-14】[Python太低级，我选 C++？码农带你揭穿少儿编程的骗局](https://www.toutiao.com/i6921532950840476174)


## 代码如何被CPU执行

[简单！代码原来是这样被CPU跑起来的](https://www.cnblogs.com/jiazhuangdongbiancheng/p/15521829.html)

- <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8463b24f49d4c50a51ccfe5900ff0fc~tplv-k3u1fbpfcp-watermark.awebp" width="70%" >

像C++/java/python这些高级语言写的程序没法被直接运行，因为计算机只认识0、1这样的二进制，简称**机器码**，我们写的代码（高级语言）需要替换成机器码，计算机才能执行。这个转换的过通常叫「**编译**」。

hello.c

```c
#include <studio.h>
int main() 
{
   printf("Hello World\n");
   return 0;
}
```

Linux下用GCC来编译Hello World程序

```shell
gcc hello.c # 编译代码，输出可执行文件
./hello # 可执行的二进制文件
# Hello World
```

编译的过程很复杂，分为4个步骤：**预处理**(Prepressing)、**编译**(Compliation)、**汇编**(Assertmbly)和**链接**(Linking)。
- （1）**预编译**：处理源代码中以“#”开始的预编译指令，比如“#include”、“define”等。
- （2）**编译**：把预处理完的文件进行词法分析、语法分析、语义分析及优化后生产成相应的汇编代码，这个过程是最复杂的。
- （3）**汇编**：将汇编代码转换成机器码，也就是上图的目标文件hello.o
- （4）**链接**：代码程序经常是由多个代码文件组成的，当每个文件都被汇编成“.o”文件时，需要一套机制将它们「组装」在一起，这个过程就叫做链接。
- ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcc651436d3f47fb8627cb343ec6e8c5~tplv-k3u1fbpfcp-watermark.awebp)

站在CPU的视角来看看Hello World是如何被打印出来的。

### 连接-中转站和高速公路

首先编译好的文件是存在磁盘上的，得先加载到内存中。CPU通过总线和芯片打通了磁盘、内存之间的通信
- 问：为什么CPU不能直接读取磁盘的程序运行而要经过内存？
- 答：慢，缓慢的磁盘会影响我们程序执行的速度，因此需要更加快速、离CPU更近的存储，那就是内存。内存是一大块存储空间，可以存储很多数据信息
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6454fd4ce5c499aad4c0050cbe4e46c~tplv-k3u1fbpfcp-watermark.awebp" width="50%" >
- 问：如何找到程序？
- 答：地址，每个字节在内存中都有一个地址，这样当CPU去内存中读程序时，只需要根据对应的地址就可以知道程序的具体内容。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b78698efab3f4f1a9f27c0a5f603f594~tplv-k3u1fbpfcp-watermark.awebp" width="50%" >
- 问：CPU是如何与内存、磁盘通信？
- 答：通过主板上的**总线**和**芯片组**，总线好理解，就像高速公路，数据信息可以通过这条高速公路传递到CPU中。电脑主板上芯片很多，这里说的主要是**南桥**芯片和**北桥**芯片。
  - **北桥**芯片：北桥负责高速设备和CPU之间的沟通，主要就是CPU和内存、显卡之间的通信，但是随着技术的迭代，主板上的北桥芯片已经被内置到了CPU里了。
  - **南桥**芯片：南桥负责低速设备和北桥之间的通信，主要负责I/O总线之间的通信，如USB、LAN、ATA、SATA、音频控制器、键盘控制器、实时时钟控制器、高级电源管理等
- 问：为什么CPU与高速设备、低速设备之间的通信需要这两个芯片？CPU自己不能干吗？
- 答：① 任务分工，如果把所有的任务都交给CPU来处理，CPU太忙；② 备份，如果南桥芯片坏了，可以直接更换南桥，而不用换掉整个CPU。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5c8c14ce4c4244881e829ee77c6c6f~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >

### CPU-最强大脑

CPU 全称是 Central Processing Unit，即**中央处理单元**，本质是一块超大规模的集成电路。从逻辑上来分，它的内部是由**寄存器**、**控制器**、**运算器**和**时钟**组成的，下面来解释下各个组成是干什么的。
- **寄存器**：CPU内部其实有很多类型的寄存器，我们只需了解寄存器就是暂存数据、指令等信息的，它的本质是临时存储，由于是直接集成在CPU内部，所以读写它们的速度很快，一般一个CPU内部会有20-100个寄存器，这里给大家列举下常用寄存器与其功能。
  - 累加寄存器：存储执行运算的数据和运算后的数据
  - 标志寄存器：存储运算处理后的CPU的状态
  - 程序计数器：存储下一条指令所在内存的地址
  - 基址寄存器：存储数据内存的起始地址
  - 变址寄存器：存储基址寄存器的相对地址
  - 通用寄存器：存储任意数据
  - 指令寄存器：存储指令，CPU内部使用，程序员无法通过程序对该寄存器进行读写操作
  - 栈寄存器：存储栈区域的起始地址
- **控制器**：控制器负责把数据读出或者写入寄存器，并根据指令的结果来控制计算机。
- **运算器**：从名字就可以猜出来，运算器的主要工作就是运算，运算从内存读入寄存器的值
- **时钟**：它并不是我们见的钟表概念，它代表了你的CPU的工作频率，频率越高说明你的CPU处理的速度越快，但是越快就会带来另一个问题：散热。
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fba39fd3cbf04d888b8db4653d303dfd~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >

CPU的大致工作流程如下：
- 在时钟信号到来的时候，就开始工作，通过控制器把内存的数据读到各个寄存器中，然后如果有计算相关的逻辑，就交给运算器。发现没有，CPU的工作其实挺简单的，本质就是不停的读指令、执行指令。
  
但是CPU是如何读到代码指令的，以及代码里面的if else、函数调用都是如何执行分支判断、函数跳转的？

示例：伪代码，有分支判断、有函数跳转。

```c
a = 1 #0x0010
b = 2 #0x0011
if a > b { #0x0012
 printf("%s","a") #0x0013
} else { 
 add(a,b) #0x0014
} 
printf("%s","end") #0x0017

func add(int a,int b) { #0x0020
  return a+b
}
```

执行过程：
- <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f1263709ee543209dc39bc23c7c83a3~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >
- 首先每段程序都有个开始的地址0x0010，也就是CPU读取程序的入口
- 把a=1这个数字读入通用寄存器中，程序计数器（PC寄存器）自动加1，即指向下一条指令 0x0011
- 指令寄存器拿到程序计数器的指令地址，把b=2这个数字读入通用寄存器中，程序计数器（PC寄存器）自动加1，即指向下一条指令0x0012
- 指令寄存器发现此处是比较逻辑，会执行a-b，此时可能会有三个结果分别是大于0，等于0，小于0，然后把这个结果存到标志寄存器里
  - 知识点：经常说的是CPU是64位或者32位，其实也表示了标志寄存器的长度
  - <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e640e071a8484ae99404346020619936~tplv-k3u1fbpfcp-watermark.awebp" width="80%" >
- 很明显，a是小于b的，CPU根据标志寄存器的状态值应该跳转到else里面，注意这时程序计数器的值不是加1，而是设置成else的地址 0x0014，当执行到0x0015的时候，需要发生函数跳转，程序计数器会被设置成 0x0020，但是这里并不是简单的函数跳转（专业术语叫做call），因为在函数执行完毕之后，还要返回，也就是程序计数器需要从0x0020再变成0x0017。call执行的时候会把后续要执行的指令地址0x0017存到栈中。
- 当add函数执行完，会有个return，return的时候会把上一步骤存入栈中的地址0x0017写入程序计数器中
- 指令寄存器根据程序计数器当前的地址执行最后的打印（end），结束。

总结：
- **顺序执行**的指令代码，程序计数器会自动累加（当然不一定累加的是1），然后找到下一条要执行的指令。
- **分支判断**时，程序计数器不是简单的累加地址，需要地址的跳转。
- **函数调用**不仅仅需要跳转地址，还要把函数执行完毕之后要执行的地址存下来，方便折回继续执行。
- 其实还有个**循环执行**，也就是代码中的for、while之类的，这时程序计数器会不停的在某些地址之间来回切换。



# 其它

## 少儿编程

- 【2021-3-14】[Python太低级，我选 C++？码农带你揭穿少儿编程的骗局](https://www.toutiao.com/i6921532950840476174)
- 少儿编程该怎样入门?
- 从我个人经验来说，学好编程只需要两个条件：
  - 带着目标学习
  - 一个字一个字亲手写代码
- 学习编程其实是一个非常庞大的过程，你需要学完编程语言、标准库、常用第三方库、网络协议、数据库、操作系统、数据结构、常用算法等一大堆内容，才能真正做一个产品级的程序。但是对于少儿编程来说，学好编程语言本身，一点点标准库和第三方库，也可以做出一些好玩的程序。
- 对于娃是否应该学习编程这件事情，如果中高考不考，可以完全不用学。Tony 老师往往告诉你学习编程，可以训练小朋友逻辑思维，让小朋友数学更好。但真相却恰恰相反，是逻辑思维好的小朋友，学编程更容易而已。
- 编程语言中用到的数学逻辑只有 3 个:
  - 条件判断
  - 循环
  - 递归
- 所以入门编程，你最需要的是给娃定一个目标，让他能带着任务学习，比如编写一个小小的游戏，或者让机器人跑起来。有了目标，就可以按照下图一步一步开始学习：
  - ![](https://p3-tt.byteimg.com/origin/pgc-image/aee41b60a1f143369f9dcef63f083be7?from=pc)
- 解释
  - 学完蓝色部分，基本什么也做不了，但是对编程本身会有非常清晰的概念，大部分娃学到这里也就结束了。
  - 学完橙色部分，就可以实现有趣的小游戏，或者让机器人随心所欲跑来跑去，娃会有满满的乐趣和成就感。
  - 绿色和紫色部分，预留给走专业路线的娃，如果上了高中依然热爱编程，并且有剩余精力，可以开始学习这两部分内容。不过即使学完紫色部分，也不代表编程就学完了
- 展示一下专业码农的[路线图](https://p3-tt.byteimg.com/origin/pgc-image/7eb17b3f555a44babf724f1283de9fb4?from=pc)，英文原版图谱:[前端知识图谱](https://roadmap.sh/frontend),[后端知识图谱](https://roadmap.sh/backend):
  - ![](https://p3-tt.byteimg.com/origin/pgc-image/7eb17b3f555a44babf724f1283de9fb4?from=pc)
  - 学完这些，才能差不多找一份互联网中级码农的工作，而且职业生涯还比较艰辛。行业变化特别快，技术天天都更新，工资全是加班费，年轻人便宜还玩命。
- 总结
  - 不要让娃从 C++ 入门编程，这样只会加速娃放弃学习
  - 学习编程不会提高娃的数学成绩，也不会提高逻辑思维能力
  - 绝大部分娃最终都会放弃，不要对娃有太高的期许，保留乐趣最重要
  - 如果娃有兴趣，坐得住，老师靠谱，可以从 Python 入门编程


# 结束